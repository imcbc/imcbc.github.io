<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AirProbe</title>
    <url>/2022/04/09/airprobe/</url>
    <content><![CDATA[<p>测量PM2.5浓度、二氧化碳浓度、温度、湿度</p>
<div style="width:40%;margin:auto"><img src="/2022/04/09/airprobe/ap.JPG" class="" title="AirProbe"></div>
<span id="more"></span>

<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><ul>
<li>测试PM2.5浓度</li>
<li>测试CO2浓度</li>
<li>测试温度、湿度</li>
<li>可通过环境光调整屏幕亮度</li>
<li>可选：发送信息至SensorHub</li>
<li>固件可通过USB-DFU更新</li>
<li>PCB设计</li>
<li>3D打印外壳</li>
</ul>
<hr>
<h1 id="主要部件"><a href="#主要部件" class="headerlink" title="主要部件"></a>主要部件</h1><ul>
<li>主控：    STM32F103RBT6</li>
<li>EEROM：   AT24C02</li>
<li>LDO：     AMS1117-3.3</li>
<li>RF：      CC1103</li>
<li>PM2.5     PMS5003</li>
<li>LCD       TJC3224T022</li>
<li>CO2       SCD30</li>
</ul>
<hr>
<h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><div style="width:70%;margin:auto"><img src="/2022/04/09/airprobe/ap5.JPG" class="" title="外壳设计"></div>
<div style="width:70%;margin:auto"><img src="/2022/04/09/airprobe/ap2.JPG" class="" title="组装前"></div>
<div style="width:70%;margin:auto"><img src="/2022/04/09/airprobe/ap3.JPG" class="" title="侧视图"></div>
<div style="width:70%;margin:auto"><img src="/2022/04/09/airprobe/ap4.JPG" class="" title="组装后"></div>
<div style="width:70%;margin:auto"><img src="/2022/04/09/airprobe/ap1.JPG" class="" title="安装后"></div>

<hr>
<h1 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h1><p><a href="https://github.com/imcbc/airprobe">AirProbe</a></p>
<hr>
]]></content>
      <categories>
        <category>DIY</category>
      </categories>
      <tags>
        <tag>ARM</tag>
        <tag>STM32</tag>
        <tag>嵌入式</tag>
        <tag>PetProjects</tag>
        <tag>ProjectReverie</tag>
      </tags>
  </entry>
  <entry>
    <title>ARM Cortex M33非对齐访问</title>
    <url>/2022/04/10/cm33-uac/</url>
    <content><![CDATA[<p>前一阵子在某芯片上遇到了一个设计问题：芯片中的控制核为ARM Cortex-M33内核（SSE200 IP），并在芯片中存在多个物理地址并不连续的SRAM，其中M33 Local Mem地址范围为0x2000_0000, 另一内存地址为0x41xx_xxxx. </p>
<p>遇到的具体问题为，在locam memory中，任何的非对齐访问全是正常的，但是在0x41xx_xxxx为基地址的内存上，任何非对齐的访问将会导致芯片卡死。</p>
<span id="more"></span>

<p>后经过仿真分析发现，Cortex M33处理器，如果地址[31:29]为0或者1， arm在总线上会发出两个非对齐访问（胶水逻辑）， 但如果[31:29]为2，则没有非对齐访问的操作。</p>
<p>后查找手册</p>
<ul>
<li><p>根据Cortex-M33 TRM r1p0 38页：<br>  对于Device类型的内存，不允许非对齐访问并会产生错误异常</p>
<div style="width:100%;margin:auto"><img src="/2022/04/10/cm33-uac/cm33uac1.JPG" class="" title="CM33-TRM"></div>
</li>
<li><p>根据Cortex-M33 TRM r1p0 161页面：<br>  对于Device类型的内容，非对齐访问的结果为不可预测，在Cortex-M33上会禅城非对齐的UsageFault。这里面奇怪的是在此芯片上并未产生Usage Fault（可被捕获），而是完全停止响应，似乎更像陷入到不可预测的锁死窗台，似乎和IP的配置有关？</p>
<div style="width:100%;margin:auto"><img src="/2022/04/10/cm33-uac/cm33uac2.JPG" class="" title="CM33-TRM2"></div>
</li>
<li><p>根据Armv8-M ARM(DDI0553 B.s), B7.11 Device memory:</p>
<ul>
<li>Device memory is a memory type that is assigned to regions of memory where accesses can have side effects.</li>
<li>Device memory is not cacheable.</li>
<li>…</li>
<li>Any unaligned access to Device memory generates an UNALIGNED UsageFault exception</li>
</ul>
</li>
</ul>
<div class="note info"><p>至此，已经知道arm对于不同的memory type(Normal&#x2F;Device)使用了不同的访问逻辑， 那么对应到这个具体的出错案例，0x2000_xxxx 和 0x41xx_xxxx的memory type呢？</p>
</div>


<ul>
<li>根据Armv8-M ARM, B8.1 System address map:<div style="width:100%;margin:auto"><img src="/2022/04/10/cm33-uac/cm33uac3.JPG" class="" title="CM33-ARM1"></div></li>
</ul>
<p>所以，0x41xx_xxxx在CM33下默认映射就是Device类型的访问，其根本不支持非对齐访问，这也正是这个问题的根源。</p>
<p>那么ARM为什么要这么约束呢？</p>
<p>根据AMBA总线AHB协议中地址的限定，其支持单字节，双字节，四字节的地址类型，双字节时，HADDR[0]&#x3D;1’b0, 四字节时，HADDR[1:0]&#x3D;2’b00。所以，当CPU遇到指令集发出非对齐访的ld&#x2F;st时，那么就遇到了第一个问题：是否原封不动的发出总线请求：</p>
<ul>
<li>如果原封不动的发出请求，则违反总线协议</li>
<li>如果在处理器外围增加胶水逻辑，负责拆分非对齐的总线请求，这样能做到对软件透明，但是会遇到另外一个问题：这个拆分对软件并不透明，对于外设寄存器这样的类型的访问，被拆分成两次以上独立的访问有可能与硬件的规划是冲突的，比如利用非对齐地址更改Bit8和Bit4, 加入硬件期待的时这两个Bit同时置位，但CPU却因为非对齐地址的问题这两个比特的更新被拆分为了两次操作完成，而这样的操作是软件、调试器不可感知的。</li>
</ul>
<div class="note info"><p>通过这样限定内存地址类型来调整CPU的行为似乎就显得非常合理了，SRAM类型的就为了满足软件的自由度可以进行自由拆分，而外设类型的地址访问，则考虑到某些硬件外设的特殊时许要求，则需要保持“as-is”这样的逻辑。</p>
</div>

<p>那么，这次遇到的0x41xx_xxxx地址的内存，其实也属于SoC架构的小疏忽了，不应该让一个SRAM类型的地址被映射到0x4xxx_xxxx这样的地址范围上，从而让ARM认为这是个Device, 而非SRAM。</p>
<p>而问题的修补办法只有软件限制非对齐访问，当然这样的访问也并非全是坏事：可以减少非对齐访问导致增加的额外周期，提高CPU对内存访问效率。</p>
]]></content>
      <categories>
        <category>SoC Design</category>
      </categories>
      <tags>
        <tag>ARM</tag>
        <tag>嵌入式</tag>
        <tag>Cortex-M33</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Jlink-SWD下载与调试Raspberry Pi Pico</title>
    <url>/2022/04/09/pipico-swd/</url>
    <content><![CDATA[<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>Raspberry Pi Pico提供了除了默认通过按键-上电-枚举U盘的方式下载外，同时提供了SWD接口用来下载和单步调试，这种方式非常易于调试，可以避免频繁的拔插USB。使用环境为Windows10.</p>
<span id="more"></span>
<p>RPi官方提供的最直接的环境是使用另外一个PiPico作为USB-SWD Bridge, 烧写PicoProbe固件并用来调试其他PiPico, 但是如果已经有其他USB-SWD调试器，也是可以使用的</p>
<hr>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ul>
<li>编译可执行的Pi Pico可执行文件， 假设文件位置为当前位置，文件名为testcode.elf</li>
<li>JLink(v9)一套， 接口如图，需要连接SWDIO， SWCLK， VTref和GND  <div style="width:30%;margin:auto"><img src="/2022/04/09/pipico-swd/jlink_swd.JPG" class="" title="JLink-SWD接口"></div></li>
</ul>
<hr>
<h1 id="安装Pi-Pico-OpenOCD"><a href="#安装Pi-Pico-OpenOCD" class="headerlink" title="安装Pi Pico OpenOCD"></a>安装Pi Pico OpenOCD</h1><h3 id="Win10下安装MSYS2"><a href="#Win10下安装MSYS2" class="headerlink" title="Win10下安装MSYS2"></a>Win10下安装MSYS2</h3><ul>
<li><p>官方提供的Windows下安装PiPico方法是首先安装<a href="https://www.msys2.org/">MSYS2</a></p>
</li>
<li><p>安装完成后执行</p>
<blockquote>
<p>pacman -Syu</p>
</blockquote>
</li>
<li><p>完成后窗口自动关闭，确保打开64bit版本后执行</p>
<blockquote>
<p>pacman -Su</p>
</blockquote>
</li>
<li><p>更新完后安装依赖</p>
<blockquote>
<p>pacman -S mingw-w64-x86_64-toolchain git make libtool pkg-config autoconf automake texinfo mingw-w64-x86_64-libusb</p>
</blockquote>
<h3 id="编译安装OpenOCD"><a href="#编译安装OpenOCD" class="headerlink" title="编译安装OpenOCD"></a>编译安装OpenOCD</h3></li>
<li><p>安装完成后，打开MSYS MinGW x64</p>
</li>
<li><p>下载安装openocd包</p>
<blockquote>
<p> git clone <a href="https://github.com/raspberrypi/openocd.git">https://github.com/raspberrypi/openocd.git</a> –branch rp2040 –depth&#x3D;1</p>
</blockquote>
</li>
<li><p>编译</p>
<blockquote>
<p>cd openocd<br>.&#x2F;bootstrap<br>.&#x2F;configure –enable-picoprobe –disable-werror<br>make -j4<br>make install</p>
</blockquote>
</li>
<li><p>测试(出现错误正常)</p>
<blockquote>
<p>src&#x2F;openocd.exe</p>
</blockquote>
</li>
</ul>
<hr>
<h1 id="JLink驱动"><a href="#JLink驱动" class="headerlink" title="JLink驱动"></a>JLink驱动</h1><ul>
<li>由于使用的是OpenOCD, 所以并不能直接使用Segger提供的JLink的驱动，下载<a href="https://zadig.akeo.ie/">Zading</a></li>
<li>打开Zading选择List All Device  <div style="width:60%;margin:auto"><img src="/2022/04/09/pipico-swd/zading1.JPG" class="" title="List All Device"></div></li>
<li>选取JLink对应的接口，原驱动应为jlink (vx.xx.x.x), 替换为WinUSB, 点击替换驱动按钮  <div style="width:60%;margin:auto"><img src="/2022/04/09/pipico-swd/zading2.JPG" class="" title="Replace Driver"></div></li>
</ul>
<hr>
<h1 id="通过SWD下载"><a href="#通过SWD下载" class="headerlink" title="通过SWD下载"></a>通过SWD下载</h1><p>在MSYS2 MinGW x64中执行</p>
<blockquote>
<p>openocd -f interface&#x2F;jlink.cfg -c “transport select swd” -c “adapter_khz 6000” -f target&#x2F;rp2040.cfg -c “program testcode.elf verify reset exit”</p>
</blockquote>
<p>其中-f interface&#x2F;jlink.cfg用来选择调试器为JLink, 其后面的-c “transport select swd”用于切换调试接口为SWD，JLink默认的接口类型为JTAG，所以这个配置必须紧跟当前的-f interface&#x2F;jlink.cfg</p>
<p>-c “adapter_khz 6000”选择当前SWD频率， 也必须位于-f interface&#x2F;jlink.cfg 之后，且下一个-f xxx 之前</p>
<hr>
<h1 id="通过SWD调试"><a href="#通过SWD调试" class="headerlink" title="通过SWD调试"></a>通过SWD调试</h1><h3 id="安装GDB-Client"><a href="#安装GDB-Client" class="headerlink" title="安装GDB Client"></a>安装GDB Client</h3><p>下载安装最新的GNU ARM GCC编译器</p>
<h3 id="安装调试界面"><a href="#安装调试界面" class="headerlink" title="安装调试界面"></a>安装调试界面</h3><p>调试界面可以是常用的Eclipse或者基于VSCode改造，我已经安装了STM32CubeIDE， 也是基于Eclipse内核的，所以就直接用STM32CubeIDE了。 如果是安装Eclipse, 可以使用C&#x2F;C++版本，选择安装arm相关的调试包即可。</p>
<h3 id="调试下载"><a href="#调试下载" class="headerlink" title="调试下载"></a>调试下载</h3><ul>
<li>MSYS2 MinGW x64启动OpenOCD为GDB Server:<blockquote>
<p>openocd -f interface&#x2F;jlink.cfg -c “transport select swd” -c “adapter_khz 6000” -f target&#x2F;rp2040.cfg</p>
</blockquote>
</li>
<li>打开STM32CubeIDE调试配置页面：<ul>
<li>新建GDB Hardware Debugging</li>
<li>Project: 名字随便起</li>
<li>C&#x2F;C++ Application: 指向testcode.elf</li>
<li>Disable Auto Build<img src="/2022/04/09/pipico-swd/ide1.JPG" class="" title="GDBClientCfg1"></li>
</ul>
</li>
<li>配置Debugger Pannel:<ul>
<li>GDB Command指向安装的arm gcc工具链下面的arm-none-eabi-gdb</li>
<li>使用Remote Target</li>
<li>Remote Target类型为OpenOCD</li>
<li>Host Name: localhost</li>
<li>Port Number: 3333<img src="/2022/04/09/pipico-swd/ide2.JPG" class="" title="GDBClientCfg2"></li>
</ul>
</li>
<li>Startup页面配置：可以根据需要调整<img src="/2022/04/09/pipico-swd/ide3.JPG" class="" title="GDBClientCfg3"></li>
<li>Apply &amp; Debug</li>
</ul>
]]></content>
      <categories>
        <category>PiPico</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>PetProjects</tag>
        <tag>PiPico</tag>
        <tag>Jlink</tag>
        <tag>SWD</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>ARM Cortex-M33数据断点和TRAP功能</title>
    <url>/2022/04/12/arm-dwt/</url>
    <content><![CDATA[<p>日常调试中，除了需要在指令执行上插入断点以进行跟踪或单步调试，在某些情况下，也需要跟踪数据变化并当某内存数据发生变化时产生断点。 </p>
<p>这个功能在ARM Cortex-M33中，可以通过利用DWT实现。</p>
<span id="more"></span>

<h1 id="配置DWT"><a href="#配置DWT" class="headerlink" title="配置DWT"></a>配置DWT</h1><h3 id="打开DWT功能"><a href="#打开DWT功能" class="headerlink" title="打开DWT功能"></a>打开DWT功能</h3><p>在Secure模式下修改DEMCR(0xE000EDFC)寄存器中打开DWT功能:</p>
<div style="width:100%;margin:auto"><img src="/2022/04/12/arm-dwt/dwt1.PNG" class="" title="DEMCR"></div>
<div style="width:100%;margin:auto"><img src="/2022/04/12/arm-dwt/dwt2.PNG" class="" title="DEMCR_TRCENA"></div>

<h3 id="配置比较器"><a href="#配置比较器" class="headerlink" title="配置比较器"></a>配置比较器</h3><p>回到Non-Secure下，修改DWT_COMP<n>寄存器，n的范围为硬件支持DWT比较器个数， DWT_COMP0的地址是0xE0001020，<br>在此寄存器中填入希望跟踪的地址，例如0x2800_8000：</p>
<div style="width:100%;margin:auto"><img src="/2022/04/12/arm-dwt/dwt3.PNG" class="" title="DWT_COMP0"></div>

<p>DWT比较器可以跟踪多种类型，比如cycle count, PC地址，这里只关心Data Access:</p>
<div style="width:100%;margin:auto"><img src="/2022/04/12/arm-dwt/dwt4.PNG" class="" title="DWT_COMP0_DATA"></div>

<h3 id="使能比较器"><a href="#使能比较器" class="headerlink" title="使能比较器"></a>使能比较器</h3><p>DWT_FUNCION<n>寄存器的基地址为0xE0001028, 内容如下：</p>
<div style="width:100%;margin:auto"><img src="/2022/04/12/arm-dwt/dwt5.PNG" class="" title="DWT_FUNC1"></div>
其中，[31:27] ID位， [24] MATCHED位为只读

<p>DATASIZE（此处配置为4BYTE）</p>
<div style="width:100%;margin:auto"><img src="/2022/04/12/arm-dwt/dwt6.PNG" class="" title="DWT_FUNC2"></div>

<p>ACTION（此处配置为2’b01， Generate debug event)</p>
<div style="width:100%;margin:auto"><img src="/2022/04/12/arm-dwt/dwt7.PNG" class="" title="DWT_FUNC3"></div>

<p>MATCH:<br>MATCH位较为复杂，具体参考armv8m-arm D2.2.62 DWT_FUNCTION<n>, 此处配置为4’b0101, 即Data Address Write</p>
<div style="width:100%;margin:auto"><img src="/2022/04/12/arm-dwt/dwt8.PNG" class="" title="DWT_FUNC4"></div>

<p>最终DWT_FUNCTION0 &#x3D; 0x58000815</p>
<h1 id="挂载调试器"><a href="#挂载调试器" class="headerlink" title="挂载调试器"></a>挂载调试器</h1><p>挂在GDB Server:</p>
<div style="width:100%;margin:auto"><img src="/2022/04/12/arm-dwt/dwt9.PNG" class="" title="JLINK_GDBSERVER"></div>

<p>打开GDB Client 并继续程序</p>
<blockquote>
<p>target remote localhost:2331<br>monitor halt<br>info reg<br>c</p>
</blockquote>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>完成了DWT使能、DWT_COMP0、DWT_FUNCION0的配置后，如果有data access到测试地址0x2800_8000将会产生调试时间并被调试器捕获进而可以展开更多调试：</p>
<div style="width:100%;margin:auto"><img src="/2022/04/12/arm-dwt/dwt10.PNG" class="" title="Capture"></div>



<h1 id="TRAP"><a href="#TRAP" class="headerlink" title="TRAP"></a>TRAP</h1><p>类似的， 既然ARM可以监测到数据变化并产生debug event, 那也是可以产生Debug Monitor Excpetion，从而不用调试器就可以拦截特定地址的数据访问或者指令访问。</p>
<div class="note info"><p>这种在某些应用场合会非常的有帮助，比如无法一直挂在调试器，又或者当部分代码是按照lib的形式存储在ROM上，而随着软件的升级部分功能需要替换，或者ROM上的代码有部分bug, 为了不完全替换ROM code(可能会浪费大量内存)， 可以把需要替换的代码的入口地址加入监视目标，当程序跳转此处时产生中断，打断当前执行并进行替换。通常此类操作为TRAP &amp; CATCH。</p>
</div>

<p>而使用方法则非常简单，在前面提到的DEMCR寄存器[16]位MON_EN置位为1即可，如果有对应地址或者指令的访问，Secure端的Debug Monitor Exception将会执行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CoreDebug-&gt;DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;</span><br><span class="line">CoreDebug-&gt;DEMCR |= CoreDebug_DEMCR_MON_EN_Msk;</span><br><span class="line">DWT-&gt;CTRL |= DWT_CTRL_CYCCNTENA_Msk;</span><br><span class="line">DWT-&gt;CYCCNT = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SoC Design</category>
      </categories>
      <tags>
        <tag>ARM</tag>
        <tag>嵌入式</tag>
        <tag>Cortex-M33</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义OpenHab串口设备</title>
    <url>/2022/04/15/openhab-serial/</url>
    <content><![CDATA[<h1 id="HomeAssistant、OpenHab使用经验总结"><a href="#HomeAssistant、OpenHab使用经验总结" class="headerlink" title="HomeAssistant、OpenHab使用经验总结"></a>HomeAssistant、OpenHab使用经验总结</h1><p>几年前在Raspberry Pi上用过一短时间的HomeAssistant，并且通过一些比较复杂的方法，把一些WIFI遥控开关，红外线桥等设备连入，可以进行简单的远程控制，并添加了一些自动脚本，比如空气污染严重时开启新风机，下雨时关闭新风机等操作。但是在实际使用过程中还是发现了不少问题：</p>
<span id="more"></span>
<ol>
<li><p>HomeAssistant后续的官方版本，在镜像被烧在TF卡后的初次启动，需要大量的从网络上下载组件，这非常费时间，在网络不好的时候几个小时甚至一两天都不会有任何进展，而初次安装时系统没有任何交互功能，包括屏幕，串口等，所以完全不知道具体进展;</p>
</li>
<li><p>虽然提供了Web UI来展示各种传感器信息或者控制，但是配置这些模块却需要通写脚本来完成，需要熟悉这些配置的脚本却需要大量的时间，HA提供的手册信息非常有限，需要大量的从社区获得这些知识;</p>
</li>
<li><p>HA当时并没有官方的云服务，所以需要自己搭建内网穿透从而实现远程控制，我搭建了一个脚本来完成这件事件，但是考虑了安全性时又增加了很多保护，验证的工作，这增加了维护的工作量;</p>
</li>
<li><p>HA的一大优势是拥有非常多的插件，几乎任何常见的智能设备都能找到对应的插件。但是鉴于当时智能设备毫无统一标准，有些插件并不易用，甚至需要一定程度的hack才能将设备添加进HA，这个也增加了维护的成本;</p>
</li>
<li><p>而我的需求则是，需要搭建一套自己的IOT网络，它通过串口与Raspberry Pi相连，可以直接在网桥里面管理设备，HA提供一套web&#x2F;app界面，然而在HA中我没有找到可以直接管理串口的插件，但是HA可以调用系统里面的程序或者python脚本（相当于Terminal管道？），但是这样会导致系统结构就变成了HA&lt;&#x3D;&#x3D;&#x3D;&#x3D;&gt;通信脚本&lt;–UART–&gt;Gateway, 从而导致一旦需要添加或者维护设备，就需要通过Web调整HA，通过SSH连接RPi修改通信脚本，通过串口修改Gateway, 进一步增加了维护成本;</p>
</li>
</ol>
<p>各种原因的综合下，经过几年的使用HA逐渐被废弃。</p>
<p>最近发现OpenHab提供了一些非常有意思的功能：</p>
<ol>
<li>HA同样提供了数量庞大的插件库;</li>
<li>HA支持HA Cloud, 可以自己搭建也可以用官方推荐的免费云服务作为中专服务;</li>
<li>HA支持串口设备，可以直接通过串口添加外部设备;<br>最后OH的安装过程也很友好。</li>
</ol>
<h1 id="OpenHab结构"><a href="#OpenHab结构" class="headerlink" title="OpenHab结构"></a>OpenHab结构</h1><p>刚开始接触OpenHab时，对其工作模型非常的迷惑，应该时为了追求灵活性的原因，OH提供了Things, Items, Channels这样的概念。这三者联合起来才组成一个完整的设备模型。从数据流的角度来思考，更像是Things-&gt;Channels-&gt;Items, 最终在UI上可以添加对应的Items，从而展示数据或者控制设备。<br>例如，一个Things::SerialDevice可以从串口收集数据，这些数据被送到一个Channel里面，完整对应的parser, 最终Items::Temerature这样的终端接受Channel里面的数据，并转换为对应的类型，如温度，湿度等等.</p>
<h1 id="OpenHab-Serial-Device"><a href="#OpenHab-Serial-Device" class="headerlink" title="OpenHab Serial Device"></a>OpenHab Serial Device</h1><p>如果从数据流的角度去看，OH的串口设备时一种梳状结构：<br>    <div style="width:100%;margin:auto"><img src="/2022/04/15/openhab-serial/0.png" class="" title="OH-Seiral-Structure"></div><br>通过这种树状的级联配置，通过每一级的正则表达式筛选出想要的数据，最终完成同一个串口，分发不同的数据到不同的终端节点上。</p>
<h1 id="配置Serial-Device"><a href="#配置Serial-Device" class="headerlink" title="配置Serial Device"></a>配置Serial Device</h1><ul>
<li><p>在OH中最先需要定义的就是Serial Bridge, 这个节点负责与物理上的串口进行通信，其配置：</p>
  <div style="width:100%;margin:auto"><img src="/2022/04/15/openhab-serial/1.png" class="" title="Serial Bridge"></div>
</li>
<li><p>创建最终的Item<br>  比如温度计，湿度计，开关等</p>
  <div style="width:100%;margin:auto"><img src="/2022/04/15/openhab-serial/2.png" class=""></div>
  
<p>  配置Item, 主要是配置名称和类型，其他内容则不是那么重要</p>
  <div style="width:100%;margin:auto"><img src="/2022/04/15/openhab-serial/3.png" class=""></div>
</li>
<li><p>在Things中创建Serial Device</p>
  <div style="width:100%;margin:auto"><img src="/2022/04/15/openhab-serial/4.png" class=""></div>
  
<p>  修改配置，其中要把Bridge选择为刚创建的Serial Bridge，以便能从串口收发数据，Patern Match则根据需要修改，全匹配为.*</p>
  <div style="width:100%;margin:auto"><img src="/2022/04/15/openhab-serial/5.png" class=""></div>
</li>
<li><p>在创建的Serial Device下面创建Channel<br>  创建Change时必须配置唯一的名称，在”State Transformation”中通过正则表达式过滤出目标数据， “Number Format”中格式化过滤后的数据：</p>
  <div style="width:100%;margin:auto"><img src="/2022/04/15/openhab-serial/6.png" class=""></div>

<p>  完成后通过”Add Link to Item..”从而链接到刚才创建的Item中，从而完成整条线路的配置</p>
  <div style="width:100%;margin:auto"><img src="/2022/04/15/openhab-serial/7.png" class=""></div>
</li>
<li><p>链接Channel与Item<br>  选择”Use an existing Item”，在Item to Link中选择目标</p>
  <div style="width:100%;margin:auto"><img src="/2022/04/15/openhab-serial/9.png" class=""></div>
  <div style="width:100%;margin:auto"><img src="/2022/04/15/openhab-serial/10.png" class=""></div>
  这个REGEX可以完成进一步的数据筛选，默认就是(.*),如果时需要Item获得小数点数据，比如温度这样的，可以使用 (\d*.\d*)
</li>
<li><p>特殊情况，比如开关作为串口输出设备，又是需要输出的内容带换行，但是界面提供的”On Value”和“Off Value”中都不能添加换行符，这种情况就需要在配置完成后，点击保存，然后切换到”Code”页面，在代码中中直接添加\n：</p>
  <div style="width:100%;margin:auto"><img src="/2022/04/15/openhab-serial/8.png" class=""></div>
</li>
<li><p>添加到主界面<br>  在Page栏里面，可以修改页面布局，添加对应的Item到对应的位置，并修改图标等显示相关内容：</p>
  <div style="width:100%;margin:auto"><img src="/2022/04/15/openhab-serial/11.png" class=""></div>
  <div style="width:100%;margin:auto"><img src="/2022/04/15/openhab-serial/12.png" class=""></div></li>
</ul>
]]></content>
      <categories>
        <category>DIY</category>
      </categories>
      <tags>
        <tag>PetProjects</tag>
        <tag>ProjectReverie</tag>
        <tag>SmartHome</tag>
        <tag>OpenHab</tag>
        <tag>Raspberry Pi</tag>
      </tags>
  </entry>
  <entry>
    <title>MSP430 BSL DEBUG</title>
    <url>/2022/09/12/MSP430-BSL-DEBUG/</url>
    <content><![CDATA[<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>中秋节在家，想起来MSP430系列的芯片ISP模式还没有使用过，好奇其工具链的配套的完善程度和具体的使用流程，就打算用手上的MSP430F2272来尝试一下。<br>理想中，使用ISP的好处：</p>
<ol>
<li>一个完整的产品不应该以JTAG为下载方式，就连自己的Pet Projects做完了以后，如果有设计或者使用外壳的情况，用JTAG下载也是极为不方便的，需要拆解外壳连接调试器。 </li>
<li>MSP430F2272的JTAG与ARM Cortex-M家族的SWD不同，需要至少8个PIN：<blockquote>
<p>   Vref, GND, TEST, NRST, TCK, TMS, TDI, TDO<br> 如果采用标准的2.54mm座子则非常占用电路板体积</p>
</blockquote>
</li>
</ol>
<p>常见的SoC厂商，都会在SoC的ROM（第一级引导程序）中加入ISP模式，可以通过一些简单接口就能完成固件的烧写，比如我们最近设计的芯片的ROM中就是以I2C为接口提供ISP的。所以MSP430也一定会有类似的功能。</p>
<span id="more"></span>

<h1 id="BSL"><a href="#BSL" class="headerlink" title="BSL"></a>BSL</h1><p>简单的搜索后得知，TI的给自己的MSP430起了一个不太一样的名字：BSL，二者都是一个意思，名字不同而已。<br>查找F2272 UG得到了一个用户指引教程<a href="https://www.ti.com/lit/ug/slau319ae/slau319ae.pdf?ts=1662983245041">SLAU319</a> 查表就知道F2272支持UART下载。<br>    <div style="width:80%;margin:auto"><img src="/2022/09/12/MSP430-BSL-DEBUG/0.JPG" class=""></div></p>
<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><p>经过调查，BSL的工具大概有几个：</p>
<ol>
<li>MSP-FET，非常早期的GUI工具</li>
<li>MSP-FLASHER， 命令行模式的工具</li>
<li>MSP-GANG， 应该时面向批量编程的</li>
<li>UniFlash， 应该时TI想要打造的通用Flash下载程序</li>
</ol>
<p>本来打算就用UniFlash就足够了，支持F2272， 支持第三方串口模块，但是没想到后面遇到了几个坑，最后把上面几个工具都下载并尝试了一番..但是最后还是用UniFlash成功了。</p>
<p>吐槽一下其他几个工具：<br>MSP-FLASHER, 命令行中允许执行 -i TIUSB | COMn | .., 连接上串口后执行 -i COM2后程序还是会自动尝试寻找USBFET, 没有不行..</p>
<p>MSP-GANG，打开了以后使用串口模式，永远只和COM1通信，COM2被你吃了么..</p>
<h1 id="UniFlash"><a href="#UniFlash" class="headerlink" title="UniFlash"></a>UniFlash</h1><p>打开UniFlash界面后，发现了两个问题：</p>
<ol>
<li>烧写的文件用的时.txt或者.hex, CCS默认的格式时ELF(.out)</li>
<li>ISP模式并不是只用UART就可以了，需要串口模块DTR和RTS： <div style="width:100%;margin:auto"><img src="/2022/09/12/MSP430-BSL-DEBUG/1.JPG" class=""></div>
 也就是DTR<--->NRST,  RTS<--->TEST</li>
</ol>
<p>第二个问题好办，把串口模块的DTR和RTS接出来就好，CP2102芯片是支持UART硬件流控的，第一问题，应该会有两种解决方案：用某种工具转换（TI或者第三方的）， 或者在工程中可能提供了编译链接后可以选择类似GNU下objcopy这样的功能，打开CCS寻找，还真有：<br>    <div style="width:100%;margin:auto"><img src="/2022/09/12/MSP430-BSL-DEBUG/2.JPG" class=""></div><br>    <div style="width:100%;margin:auto"><img src="/2022/09/12/MSP430-BSL-DEBUG/3.JPG" class=""></div><br>在output format中还有很多种格式选择，UniFlash也没有具体提到需要哪种具体格式的，因为没有什么时间慢慢看文档研究了，凭感觉试了两种，最后发现TI-TXT格式可行（TI全家桶么）<br>    <div style="width:100%;margin:auto"><img src="/2022/09/12/MSP430-BSL-DEBUG/4.JPG" class=""></div></p>
<p>生成好.txt后UniFlash中配置串口和波特率，点击“Load Image”提示失败，内容大概是目标设备无响应，检查了连线，按照提示反复掉电上电都没有作用。最后还是花了点时间最后弄明白了，MSP430F2272中BSL用的串口，和片内外设中提供的UART，并不一样！<br>    F2272中用的是P1.1和P2.2<br>    <div style="width:100%;margin:auto"><img src="/2022/09/12/MSP430-BSL-DEBUG/5.JPG" class=""></div><br>    而P1.1和P2.2的具体功能是<br>    <div style="width:100%;margin:auto"><img src="/2022/09/12/MSP430-BSL-DEBUG/6.JPG" class=""></div><br>    <div style="width:100%;margin:auto"><img src="/2022/09/12/MSP430-BSL-DEBUG/7.JPG" class=""></div></p>
<p>飞线后，仍然提示失败，但是错误内容不一样了，日志内容也明显是有通信和握手了，说明软件和芯片已经能正常通信了。最后重新掉电上电后再次尝试，提示成功！<br>    <div style="width:100%;margin:auto"><img src="/2022/09/12/MSP430-BSL-DEBUG/8.JPG" class=""></div></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总体来说，TI BSL相比于JTAG，在节约PIN脚上优势并不显著，仍然需要：GND，NRST，TEST，BSL-Tx, BSL-Rx五个，比前面提到的JTAG少了三个引脚，而且整体易用度上也比不上STM32的ISP和PiPico的DFU，不过依然可以搭载一个外部的USB-UART桥来完成相对完整的ISP功能，避免了在作品完成后每次需要更新固件都需要拆外壳，拆设备的尴尬。</p>
]]></content>
      <categories>
        <category>Debug</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>超低功耗设计经验总结</title>
    <url>/2022/09/21/ultra-low-power-design/</url>
    <content><![CDATA[<p>从大学开始就断断续续的摸索超低功耗系统的设计，其中撞过很多坑，通过前几次的迭代积累的经验，外加这段时间正好闲下来，完成了一个比较满意的超低功耗传感采集节点的设计，待机电流0.1uA, 工作时包括射频系统在内最大峰值电流30mA，理论上不考虑电池的自放电下，单节CR2032电池可以让设备工作数年. 总结一下经验以便后面的设计能吸取前面的教训，少走弯路。<br>几次迭代（老的设计芯片大多吹掉重新用了）：<br>    <div style="width:70%;margin:auto"><img src="/2022/09/21/ultra-low-power-design/1.JPG" class=""></div></p>
<span id="more"></span>

<h1 id="碎碎念的经验"><a href="#碎碎念的经验" class="headerlink" title="碎碎念的经验"></a>碎碎念的经验</h1><ul>
<li><p>动手设计前先认真核心的需求，根据特点和认真考察每个组件，并做好详细的计算和仿真<br>  第一次设计是在大学的时候，对嵌入式系统的设计和理解还很粗浅，低功耗设计更是没有认真考虑，选用了外部的模块和51内核C8051F的微控制器，并采用单节AA电池通过DC-DC boost电路升压，设计完成后发现的最大问题是：功耗太高了，再优化也很难让单节AA电池长期工作数月，时间太久了依稀记得经过最后的计算大概一节AA电池能工作一个月左右。</p>
<ul>
<li>这里就是没有思考低功耗系统到底该如何选择合适的微控制器，而是拿着当时熟悉的微控制器设计</li>
<li>没有考虑电源隔离， AA电池通过Boost电路升压后提供给MCU，RF和传感器供电，而待机时RF部分并不需要一直供电</li>
<li>Boost电路选型也出了问题，后面再提</li>
<li>电路设计上没有考虑过对于功耗的调试，导致具体哪部分消耗了多少电流并不容易测量，需要反复的割板飞线</li>
<li>体积控制，算是锦上添花吧，当然也可以降低PCB制造的成本</li>
<li>系统的仿真可以避免后期再PCB调试长花费过多的时间，后续版本上加入了MOS管和BJT组成的电源管理电路，而这些电路初期工作的并不理想，设置有些情况下本身就会消耗不少电</li>
</ul>
</li>
<li><p>一定要了解每一个元件的特点， 做好芯片选型</p>
<ul>
<li><p>有了第一次失败的经验，重新选型决定采用TI的MSP430F系列单片机， 这个MCU提供了多种低功耗模式的选择<br>  手册提供的数据：</p>
  <div style="width:100%;margin:auto"><img src="/2022/09/21/ultra-low-power-design/2.JPG" class=""></div>
  实际测试LPM3 （VLO->ACLK):
  <div style="width:30%;margin:auto"><img src="/2022/09/21/ultra-low-power-design/3.JPG" class=""></div>
  实际测试LPM4：
  <div style="width:30%;margin:auto"><img src="/2022/09/21/ultra-low-power-design/4.JPG" class=""></div>
</li>
<li><p>第二次则将RF部分的第三方模块改为自己设计，并采用陶瓷天线，后来证明：</p>
<ul>
<li>在未充分了解RF系统的时，尽管参考了官方设计，但是仍然在信号质量上和其他厂商的模块性能差距巨大</li>
<li>这部分差距应该主要来自于：<ul>
<li>巴伦电路的元件选型，要充分了解电感，电容的性能参数，比如精度，规格（是否是NP0）</li>
<li>周围电路布局</li>
<li>不靠谱的元器件提供商，都是淘宝买的，设置晶振都给发错了，26MHz发成了25MHz</li>
<li>天线，为了压缩体积采用了并不熟悉的陶瓷天线，而陶瓷天线的性能远不如弹簧天线</li>
</ul>
</li>
</ul>
</li>
<li><p>第一次的设计中采用了一个并不熟悉的DCDC Boost芯片，而实际使用中发现，这个芯片并不能完全达到标称负载能力，主要是响应的能力不足，也可能买到的是假芯片，在提供了2-2.5倍负载冗余的情况下，射频部分的突然工作会导致电压下降，而DCDC的输出同样要提供给微控制器 – 那么结果必然是悲剧的，触发芯片POR</p>
</li>
</ul>
</li>
<li><p>动手前考虑好软件的架构，如果有从未接触过的新模块、单片机或者其他芯片，最好先做最小系统实验，包括软件特点</p>
<ul>
<li>重复的重新设计硬件是低效的，所以真正推荐的做法是，如果遇到要探索某些部分极限性能的情况下，最好先设计一个更注硬件与软件调试的PCB（或者可以说针对这个产品的开发板），争取两个版本就能达到所有关键指标：<ul>
<li>具备丰富易用的调试接口</li>
<li>给电路修改留下足够的可能性</li>
<li>具备合格的电源</li>
<li>不用过于的注重体积</li>
</ul>
</li>
</ul>
</li>
<li><p>深入了解微控制器的低功耗特性和使用方法</p>
<ul>
<li>以MSP430单片机为例，官方虽然提供了数据LPM3&#x2F;LPM4的功耗，但真正上板时，实际测出来的功耗和手册上的差距会相当巨大，这里面包括了正确的配置芯片的频率，工作模式和GPIO，其中GPIO的配置非常重要，并不是简单的把左右的IO配置为输入、输入就可以了，需要根据具体电路调整，有些需要配置为输入，有些需要配置为输出低，而个别IO，需要在低功耗前配置为一个状态避免漏电流、灌电流，而唤醒后则需要切换到另外的状态<br>  LPM3、LPM4为例：<br>  LPM3的情况下，CPU-OFF, 所有的时钟，除了ACLK以外都将被关闭，而ACLK还可以选择外部ACLK或者内部VLO（4KHz-20KzHz, 典型值12KHz)<br>  而LPM4更为极端，CPU-OFF，所有始终都关闭，MCU只能被外部IO中断唤醒</li>
</ul>
<p>  如果需要MSP430定时自动唤醒，就只能采用LPM3， 而如果仅仅需要外部传感器唤醒，则可以采用LMP4</p>
</li>
<li><p>为了减少软件设计复杂度而采用第三方模块，将会对系统整体的低功耗设计带来挑战<br>  有了第二次的RF设计性能太差的问题，重新尝试采用第三方模块去设计，虽然RF性能上去了并且软件更为简单，但是后期再优化功耗时则更加困难，比如第三方模块采用了一个单片机，这个单片机的工作电压范围是3V-5V，如果系统考虑采用纽扣电池供电那么这将会导致需要增加DCDC-Boost电路，因为典型的CR2032电池的工作电压曲线是这样的：</p>
  <div style="width:70%;margin:auto"><img src="/2022/09/21/ultra-low-power-design/5.JPG" class=""></div>
  而增加的Boost电路本身就很难达到90%以上的实际转换效率，这就意味一部分能量被完全的浪费了，仅仅是因为电压的不匹配

</li>
<li><p>做好电源域的隔离和调试，可以随时切断不需要的电路部分的电源<br>  在必要的电源分支上预留开关或者条线对后期调试是很有帮助的，非常有助于设计者了解到底哪个子单元消耗了具体多少的电流，单纯的在电池总供电初预留这样的电流测试接口是不够的，遇到难以理解的异常电流增加那就继续割板子了</p>
</li>
<li><p>贯彻奥卡姆剃刀原则 - 如无必要、勿增实体<br>  不要增加太多无用的组件，这部分并不在核心需求中的组件反而可能干扰功耗和电路的调试，增加PCB面积和元件密度， 带来了更多的不确定型</p>
</li>
<li><p>软件设计之初的时候考虑睡眠-唤醒情况下的切换<br>  包括的驱动中和硬件寄存器无关的软件部分，要仔细考虑那些部分需要在唤醒后重新初始化</p>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>深入分析核心需求，仿真仿真仿真！如果有条件在开发板上测试软件基本功能和性能</li>
<li>复杂的项目，不要太过期望一遍成功，一次定型，条件允许下先设计调试板，足够的软件-硬件-功耗调试接口，甚至备用方案<ul>
<li>搞清楚每个组件的功耗，就容易进行更具针对性的优化，比如是外部的电路需要进入低功耗还是调整电路，亦或者电流来自于微控制器，是需要调整IO状态还是内部的时钟树的配置或者那些片内外设仍然在工作。</li>
</ul>
</li>
<li>硬件设计的时候要同时考虑软件的架构和流程，如何能与硬件配合达到最优</li>
<li>对于不太了解性能和特点的第三方模块选型要慎重</li>
</ul>
]]></content>
      <categories>
        <category>DIY</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>PetProjects</tag>
      </tags>
  </entry>
</search>
