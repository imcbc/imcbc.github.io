<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AirProbe</title>
    <url>/2022/04/09/airprobe/</url>
    <content><![CDATA[<p>测量PM2.5浓度、二氧化碳浓度、温度、湿度</p>
<div style="width:40%;margin:auto"><img src="/2022/04/09/airprobe/ap.JPG" class="" title="AirProbe"></div>
<span id="more"></span>

<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><ul>
<li>测试PM2.5浓度</li>
<li>测试CO2浓度</li>
<li>测试温度、湿度</li>
<li>可通过环境光调整屏幕亮度</li>
<li>可选：发送信息至SensorHub</li>
<li>固件可通过USB-DFU更新</li>
<li>PCB设计</li>
<li>3D打印外壳</li>
</ul>
<hr>
<h1 id="主要部件"><a href="#主要部件" class="headerlink" title="主要部件"></a>主要部件</h1><ul>
<li>主控：    STM32F103RBT6</li>
<li>EEROM：   AT24C02</li>
<li>LDO：     AMS1117-3.3</li>
<li>RF：      CC1103</li>
<li>PM2.5     PMS5003</li>
<li>LCD       TJC3224T022</li>
<li>CO2       SCD30</li>
</ul>
<hr>
<h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><div style="width:70%;margin:auto"><img src="/2022/04/09/airprobe/ap5.JPG" class="" title="外壳设计"></div>
<div style="width:70%;margin:auto"><img src="/2022/04/09/airprobe/ap2.JPG" class="" title="组装前"></div>
<div style="width:70%;margin:auto"><img src="/2022/04/09/airprobe/ap3.JPG" class="" title="侧视图"></div>
<div style="width:70%;margin:auto"><img src="/2022/04/09/airprobe/ap4.JPG" class="" title="组装后"></div>
<div style="width:70%;margin:auto"><img src="/2022/04/09/airprobe/ap1.JPG" class="" title="安装后"></div>

<hr>
<h1 id="项目地址"><a href="#项目地址" class="headerlink" title="项目地址"></a>项目地址</h1><p><a href="https://github.com/imcbc/airprobe">AirProbe</a></p>
<hr>
]]></content>
      <categories>
        <category>DIY</category>
      </categories>
      <tags>
        <tag>ARM</tag>
        <tag>STM32</tag>
        <tag>嵌入式</tag>
        <tag>PetProjects</tag>
        <tag>ProjectReverie</tag>
      </tags>
  </entry>
  <entry>
    <title>ARM Cortex M33非对齐访问</title>
    <url>/2022/04/10/cm33-uac/</url>
    <content><![CDATA[<p>前一阵子在某芯片上遇到了一个设计问题：芯片中的控制核为ARM Cortex-M33内核（SSE200 IP），并在芯片中存在多个物理地址并不连续的SRAM，其中M33 Local Mem地址范围为0x2000_0000, 另一内存地址为0x41xx_xxxx. </p>
<p>遇到的具体问题为，在locam memory中，任何的非对齐访问全是正常的，但是在0x41xx_xxxx为基地址的内存上，任何非对齐的访问将会导致芯片卡死。</p>
<span id="more"></span>

<p>后经过仿真分析发现，Cortex M33处理器，如果地址[31:29]为0或者1， arm在总线上会发出两个非对齐访问（胶水逻辑）， 但如果[31:29]为2，则没有非对齐访问的操作。</p>
<p>后查找手册</p>
<ul>
<li><p>根据Cortex-M33 TRM r1p0 38页：<br>  对于Device类型的内存，不允许非对齐访问并会产生错误异常</p>
<div style="width:100%;margin:auto"><img src="/2022/04/10/cm33-uac/cm33uac1.JPG" class="" title="CM33-TRM"></div>
</li>
<li><p>根据Cortex-M33 TRM r1p0 161页面：<br>  对于Device类型的内容，非对齐访问的结果为不可预测，在Cortex-M33上会禅城非对齐的UsageFault。这里面奇怪的是在此芯片上并未产生Usage Fault（可被捕获），而是完全停止响应，似乎更像陷入到不可预测的锁死窗台，似乎和IP的配置有关？</p>
<div style="width:100%;margin:auto"><img src="/2022/04/10/cm33-uac/cm33uac2.JPG" class="" title="CM33-TRM2"></div>
</li>
<li><p>根据Armv8-M ARM(DDI0553 B.s), B7.11 Device memory:</p>
<ul>
<li>Device memory is a memory type that is assigned to regions of memory where accesses can have side effects.</li>
<li>Device memory is not cacheable.</li>
<li>…</li>
<li>Any unaligned access to Device memory generates an UNALIGNED UsageFault exception</li>
</ul>
</li>
</ul>
<div class="note info"><p>至此，已经知道arm对于不同的memory type(Normal&#x2F;Device)使用了不同的访问逻辑， 那么对应到这个具体的出错案例，0x2000_xxxx 和 0x41xx_xxxx的memory type呢？</p>
</div>


<ul>
<li>根据Armv8-M ARM, B8.1 System address map:<div style="width:100%;margin:auto"><img src="/2022/04/10/cm33-uac/cm33uac3.JPG" class="" title="CM33-ARM1"></div></li>
</ul>
<p>所以，0x41xx_xxxx在CM33下默认映射就是Device类型的访问，其根本不支持非对齐访问，这也正是这个问题的根源。</p>
<p>那么ARM为什么要这么约束呢？</p>
<p>根据AMBA总线AHB协议中地址的限定，其支持单字节，双字节，四字节的地址类型，双字节时，HADDR[0]&#x3D;1’b0, 四字节时，HADDR[1:0]&#x3D;2’b00。所以，当CPU遇到指令集发出非对齐访的ld&#x2F;st时，那么就遇到了第一个问题：是否原封不动的发出总线请求：</p>
<ul>
<li>如果原封不动的发出请求，则违反总线协议</li>
<li>如果在处理器外围增加胶水逻辑，负责拆分非对齐的总线请求，这样能做到对软件透明，但是会遇到另外一个问题：这个拆分对软件并不透明，对于外设寄存器这样的类型的访问，被拆分成两次以上独立的访问有可能与硬件的规划是冲突的，比如利用非对齐地址更改Bit8和Bit4, 加入硬件期待的时这两个Bit同时置位，但CPU却因为非对齐地址的问题这两个比特的更新被拆分为了两次操作完成，而这样的操作是软件、调试器不可感知的。</li>
</ul>
<div class="note info"><p>通过这样限定内存地址类型来调整CPU的行为似乎就显得非常合理了，SRAM类型的就为了满足软件的自由度可以进行自由拆分，而外设类型的地址访问，则考虑到某些硬件外设的特殊时许要求，则需要保持“as-is”这样的逻辑。</p>
</div>

<p>那么，这次遇到的0x41xx_xxxx地址的内存，其实也属于SoC架构的小疏忽了，不应该让一个SRAM类型的地址被映射到0x4xxx_xxxx这样的地址范围上，从而让ARM认为这是个Device, 而非SRAM。</p>
<p>而问题的修补办法只有软件限制非对齐访问，当然这样的访问也并非全是坏事：可以减少非对齐访问导致增加的额外周期，提高CPU对内存访问效率。</p>
]]></content>
      <categories>
        <category>SoC Design</category>
      </categories>
      <tags>
        <tag>ARM</tag>
        <tag>嵌入式</tag>
        <tag>Cortex-M33</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Jlink-SWD下载与调试Raspberry Pi Pico</title>
    <url>/2022/04/09/pipico-swd/</url>
    <content><![CDATA[<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>Raspberry Pi Pico提供了除了默认通过按键-上电-枚举U盘的方式下载外，同时提供了SWD接口用来下载和单步调试，这种方式非常易于调试，可以避免频繁的拔插USB。使用环境为Windows10.</p>
<span id="more"></span>
<p>RPi官方提供的最直接的环境是使用另外一个PiPico作为USB-SWD Bridge, 烧写PicoProbe固件并用来调试其他PiPico, 但是如果已经有其他USB-SWD调试器，也是可以使用的</p>
<hr>
<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ul>
<li>编译可执行的Pi Pico可执行文件， 假设文件位置为当前位置，文件名为testcode.elf</li>
<li>JLink(v9)一套， 接口如图，需要连接SWDIO， SWCLK， VTref和GND  <div style="width:30%;margin:auto"><img src="/2022/04/09/pipico-swd/jlink_swd.JPG" class="" title="JLink-SWD接口"></div></li>
</ul>
<hr>
<h1 id="安装Pi-Pico-OpenOCD"><a href="#安装Pi-Pico-OpenOCD" class="headerlink" title="安装Pi Pico OpenOCD"></a>安装Pi Pico OpenOCD</h1><h3 id="Win10下安装MSYS2"><a href="#Win10下安装MSYS2" class="headerlink" title="Win10下安装MSYS2"></a>Win10下安装MSYS2</h3><ul>
<li><p>官方提供的Windows下安装PiPico方法是首先安装<a href="https://www.msys2.org/">MSYS2</a></p>
</li>
<li><p>安装完成后执行</p>
<blockquote>
<p>pacman -Syu</p>
</blockquote>
</li>
<li><p>完成后窗口自动关闭，确保打开64bit版本后执行</p>
<blockquote>
<p>pacman -Su</p>
</blockquote>
</li>
<li><p>更新完后安装依赖</p>
<blockquote>
<p>pacman -S mingw-w64-x86_64-toolchain git make libtool pkg-config autoconf automake texinfo mingw-w64-x86_64-libusb</p>
</blockquote>
<h3 id="编译安装OpenOCD"><a href="#编译安装OpenOCD" class="headerlink" title="编译安装OpenOCD"></a>编译安装OpenOCD</h3></li>
<li><p>安装完成后，打开MSYS MinGW x64</p>
</li>
<li><p>下载安装openocd包</p>
<blockquote>
<p> git clone <a href="https://github.com/raspberrypi/openocd.git">https://github.com/raspberrypi/openocd.git</a> –branch rp2040 –depth&#x3D;1</p>
</blockquote>
</li>
<li><p>编译</p>
<blockquote>
<p>cd openocd<br>.&#x2F;bootstrap<br>.&#x2F;configure –enable-picoprobe –disable-werror<br>make -j4<br>make install</p>
</blockquote>
</li>
<li><p>测试(出现错误正常)</p>
<blockquote>
<p>src&#x2F;openocd.exe</p>
</blockquote>
</li>
</ul>
<hr>
<h1 id="JLink驱动"><a href="#JLink驱动" class="headerlink" title="JLink驱动"></a>JLink驱动</h1><ul>
<li>由于使用的是OpenOCD, 所以并不能直接使用Segger提供的JLink的驱动，下载<a href="https://zadig.akeo.ie/">Zading</a></li>
<li>打开Zading选择List All Device  <div style="width:60%;margin:auto"><img src="/2022/04/09/pipico-swd/zading1.JPG" class="" title="List All Device"></div></li>
<li>选取JLink对应的接口，原驱动应为jlink (vx.xx.x.x), 替换为WinUSB, 点击替换驱动按钮  <div style="width:60%;margin:auto"><img src="/2022/04/09/pipico-swd/zading2.JPG" class="" title="Replace Driver"></div></li>
</ul>
<hr>
<h1 id="通过SWD下载"><a href="#通过SWD下载" class="headerlink" title="通过SWD下载"></a>通过SWD下载</h1><p>在MSYS2 MinGW x64中执行</p>
<blockquote>
<p>openocd -f interface&#x2F;jlink.cfg -c “transport select swd” -c “adapter_khz 6000” -f target&#x2F;rp2040.cfg -c “program testcode.elf verify reset exit”</p>
</blockquote>
<p>其中-f interface&#x2F;jlink.cfg用来选择调试器为JLink, 其后面的-c “transport select swd”用于切换调试接口为SWD，JLink默认的接口类型为JTAG，所以这个配置必须紧跟当前的-f interface&#x2F;jlink.cfg</p>
<p>-c “adapter_khz 6000”选择当前SWD频率， 也必须位于-f interface&#x2F;jlink.cfg 之后，且下一个-f xxx 之前</p>
<hr>
<h1 id="通过SWD调试"><a href="#通过SWD调试" class="headerlink" title="通过SWD调试"></a>通过SWD调试</h1><h3 id="安装GDB-Client"><a href="#安装GDB-Client" class="headerlink" title="安装GDB Client"></a>安装GDB Client</h3><p>下载安装最新的GNU ARM GCC编译器</p>
<h3 id="安装调试界面"><a href="#安装调试界面" class="headerlink" title="安装调试界面"></a>安装调试界面</h3><p>调试界面可以是常用的Eclipse或者基于VSCode改造，我已经安装了STM32CubeIDE， 也是基于Eclipse内核的，所以就直接用STM32CubeIDE了。 如果是安装Eclipse, 可以使用C&#x2F;C++版本，选择安装arm相关的调试包即可。</p>
<h3 id="调试下载"><a href="#调试下载" class="headerlink" title="调试下载"></a>调试下载</h3><ul>
<li>MSYS2 MinGW x64启动OpenOCD为GDB Server:<blockquote>
<p>openocd -f interface&#x2F;jlink.cfg -c “transport select swd” -c “adapter_khz 6000” -f target&#x2F;rp2040.cfg</p>
</blockquote>
</li>
<li>打开STM32CubeIDE调试配置页面：<ul>
<li>新建GDB Hardware Debugging</li>
<li>Project: 名字随便起</li>
<li>C&#x2F;C++ Application: 指向testcode.elf</li>
<li>Disable Auto Build<img src="/2022/04/09/pipico-swd/ide1.JPG" class="" title="GDBClientCfg1"></li>
</ul>
</li>
<li>配置Debugger Pannel:<ul>
<li>GDB Command指向安装的arm gcc工具链下面的arm-none-eabi-gdb</li>
<li>使用Remote Target</li>
<li>Remote Target类型为OpenOCD</li>
<li>Host Name: localhost</li>
<li>Port Number: 3333<img src="/2022/04/09/pipico-swd/ide2.JPG" class="" title="GDBClientCfg2"></li>
</ul>
</li>
<li>Startup页面配置：可以根据需要调整<img src="/2022/04/09/pipico-swd/ide3.JPG" class="" title="GDBClientCfg3"></li>
<li>Apply &amp; Debug</li>
</ul>
]]></content>
      <categories>
        <category>PiPico</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>PetProjects</tag>
        <tag>PiPico</tag>
        <tag>Jlink</tag>
        <tag>SWD</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>ARM Cortex-M33数据断点和TRAP功能</title>
    <url>/2022/04/12/arm-dwt/</url>
    <content><![CDATA[<p>日常调试中，除了需要在指令执行上插入断点以进行跟踪或单步调试，在某些情况下，也需要跟踪数据变化并当某内存数据发生变化时产生断点。 </p>
<p>这个功能在ARM Cortex-M33中，可以通过利用DWT实现。</p>
<span id="more"></span>

<h1 id="配置DWT"><a href="#配置DWT" class="headerlink" title="配置DWT"></a>配置DWT</h1><h3 id="打开DWT功能"><a href="#打开DWT功能" class="headerlink" title="打开DWT功能"></a>打开DWT功能</h3><p>在Secure模式下修改DEMCR(0xE000EDFC)寄存器中打开DWT功能:</p>
<div style="width:100%;margin:auto"><img src="/2022/04/12/arm-dwt/dwt1.PNG" class="" title="DEMCR"></div>
<div style="width:100%;margin:auto"><img src="/2022/04/12/arm-dwt/dwt2.PNG" class="" title="DEMCR_TRCENA"></div>

<h3 id="配置比较器"><a href="#配置比较器" class="headerlink" title="配置比较器"></a>配置比较器</h3><p>回到Non-Secure下，修改DWT_COMP<n>寄存器，n的范围为硬件支持DWT比较器个数， DWT_COMP0的地址是0xE0001020，<br>在此寄存器中填入希望跟踪的地址，例如0x2800_8000：</p>
<div style="width:100%;margin:auto"><img src="/2022/04/12/arm-dwt/dwt3.PNG" class="" title="DWT_COMP0"></div>

<p>DWT比较器可以跟踪多种类型，比如cycle count, PC地址，这里只关心Data Access:</p>
<div style="width:100%;margin:auto"><img src="/2022/04/12/arm-dwt/dwt4.PNG" class="" title="DWT_COMP0_DATA"></div>

<h3 id="使能比较器"><a href="#使能比较器" class="headerlink" title="使能比较器"></a>使能比较器</h3><p>DWT_FUNCION<n>寄存器的基地址为0xE0001028, 内容如下：</p>
<div style="width:100%;margin:auto"><img src="/2022/04/12/arm-dwt/dwt5.PNG" class="" title="DWT_FUNC1"></div>
其中，[31:27] ID位， [24] MATCHED位为只读

<p>DATASIZE（此处配置为4BYTE）</p>
<div style="width:100%;margin:auto"><img src="/2022/04/12/arm-dwt/dwt6.PNG" class="" title="DWT_FUNC2"></div>

<p>ACTION（此处配置为2’b01， Generate debug event)</p>
<div style="width:100%;margin:auto"><img src="/2022/04/12/arm-dwt/dwt7.PNG" class="" title="DWT_FUNC3"></div>

<p>MATCH:<br>MATCH位较为复杂，具体参考armv8m-arm D2.2.62 DWT_FUNCTION<n>, 此处配置为4’b0101, 即Data Address Write</p>
<div style="width:100%;margin:auto"><img src="/2022/04/12/arm-dwt/dwt8.PNG" class="" title="DWT_FUNC4"></div>

<p>最终DWT_FUNCTION0 &#x3D; 0x58000815</p>
<h1 id="挂载调试器"><a href="#挂载调试器" class="headerlink" title="挂载调试器"></a>挂载调试器</h1><p>挂在GDB Server:</p>
<div style="width:100%;margin:auto"><img src="/2022/04/12/arm-dwt/dwt9.PNG" class="" title="JLINK_GDBSERVER"></div>

<p>打开GDB Client 并继续程序</p>
<blockquote>
<p>target remote localhost:2331<br>monitor halt<br>info reg<br>c</p>
</blockquote>
<h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>完成了DWT使能、DWT_COMP0、DWT_FUNCION0的配置后，如果有data access到测试地址0x2800_8000将会产生调试时间并被调试器捕获进而可以展开更多调试：</p>
<div style="width:100%;margin:auto"><img src="/2022/04/12/arm-dwt/dwt10.PNG" class="" title="Capture"></div>



<h1 id="TRAP"><a href="#TRAP" class="headerlink" title="TRAP"></a>TRAP</h1><p>类似的， 既然ARM可以监测到数据变化并产生debug event, 那也是可以产生Debug Monitor Excpetion，从而不用调试器就可以拦截特定地址的数据访问或者指令访问。</p>
<div class="note info"><p>这种在某些应用场合会非常的有帮助，比如无法一直挂在调试器，又或者当部分代码是按照lib的形式存储在ROM上，而随着软件的升级部分功能需要替换，或者ROM上的代码有部分bug, 为了不完全替换ROM code(可能会浪费大量内存)， 可以把需要替换的代码的入口地址加入监视目标，当程序跳转此处时产生中断，打断当前执行并进行替换。通常此类操作为TRAP &amp; CATCH。</p>
</div>

<p>而使用方法则非常简单，在前面提到的DEMCR寄存器[16]位MON_EN置位为1即可，如果有对应地址或者指令的访问，Secure端的Debug Monitor Exception将会执行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CoreDebug-&gt;DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;</span><br><span class="line">CoreDebug-&gt;DEMCR |= CoreDebug_DEMCR_MON_EN_Msk;</span><br><span class="line">DWT-&gt;CTRL |= DWT_CTRL_CYCCNTENA_Msk;</span><br><span class="line">DWT-&gt;CYCCNT = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SoC Design</category>
      </categories>
      <tags>
        <tag>ARM</tag>
        <tag>嵌入式</tag>
        <tag>Cortex-M33</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>自定义OpenHab串口设备</title>
    <url>/2022/04/15/openhab-serial/</url>
    <content><![CDATA[<h1 id="HomeAssistant、OpenHab使用经验总结"><a href="#HomeAssistant、OpenHab使用经验总结" class="headerlink" title="HomeAssistant、OpenHab使用经验总结"></a>HomeAssistant、OpenHab使用经验总结</h1><p>几年前在Raspberry Pi上用过一短时间的HomeAssistant，并且通过一些比较复杂的方法，把一些WIFI遥控开关，红外线桥等设备连入，可以进行简单的远程控制，并添加了一些自动脚本，比如空气污染严重时开启新风机，下雨时关闭新风机等操作。但是在实际使用过程中还是发现了不少问题：</p>
<span id="more"></span>
<ol>
<li><p>HomeAssistant后续的官方版本，在镜像被烧在TF卡后的初次启动，需要大量的从网络上下载组件，这非常费时间，在网络不好的时候几个小时甚至一两天都不会有任何进展，而初次安装时系统没有任何交互功能，包括屏幕，串口等，所以完全不知道具体进展;</p>
</li>
<li><p>虽然提供了Web UI来展示各种传感器信息或者控制，但是配置这些模块却需要通写脚本来完成，需要熟悉这些配置的脚本却需要大量的时间，HA提供的手册信息非常有限，需要大量的从社区获得这些知识;</p>
</li>
<li><p>HA当时并没有官方的云服务，所以需要自己搭建内网穿透从而实现远程控制，我搭建了一个脚本来完成这件事件，但是考虑了安全性时又增加了很多保护，验证的工作，这增加了维护的工作量;</p>
</li>
<li><p>HA的一大优势是拥有非常多的插件，几乎任何常见的智能设备都能找到对应的插件。但是鉴于当时智能设备毫无统一标准，有些插件并不易用，甚至需要一定程度的hack才能将设备添加进HA，这个也增加了维护的成本;</p>
</li>
<li><p>而我的需求则是，需要搭建一套自己的IOT网络，它通过串口与Raspberry Pi相连，可以直接在网桥里面管理设备，HA提供一套web&#x2F;app界面，然而在HA中我没有找到可以直接管理串口的插件，但是HA可以调用系统里面的程序或者python脚本（相当于Terminal管道？），但是这样会导致系统结构就变成了HA&lt;&#x3D;&#x3D;&#x3D;&#x3D;&gt;通信脚本&lt;–UART–&gt;Gateway, 从而导致一旦需要添加或者维护设备，就需要通过Web调整HA，通过SSH连接RPi修改通信脚本，通过串口修改Gateway, 进一步增加了维护成本;</p>
</li>
</ol>
<p>各种原因的综合下，经过几年的使用HA逐渐被废弃。</p>
<p>最近发现OpenHab提供了一些非常有意思的功能：</p>
<ol>
<li>HA同样提供了数量庞大的插件库;</li>
<li>HA支持HA Cloud, 可以自己搭建也可以用官方推荐的免费云服务作为中专服务;</li>
<li>HA支持串口设备，可以直接通过串口添加外部设备;<br>最后OH的安装过程也很友好。</li>
</ol>
<h1 id="OpenHab结构"><a href="#OpenHab结构" class="headerlink" title="OpenHab结构"></a>OpenHab结构</h1><p>刚开始接触OpenHab时，对其工作模型非常的迷惑，应该时为了追求灵活性的原因，OH提供了Things, Items, Channels这样的概念。这三者联合起来才组成一个完整的设备模型。从数据流的角度来思考，更像是Things-&gt;Channels-&gt;Items, 最终在UI上可以添加对应的Items，从而展示数据或者控制设备。<br>例如，一个Things::SerialDevice可以从串口收集数据，这些数据被送到一个Channel里面，完整对应的parser, 最终Items::Temerature这样的终端接受Channel里面的数据，并转换为对应的类型，如温度，湿度等等.</p>
<h1 id="OpenHab-Serial-Device"><a href="#OpenHab-Serial-Device" class="headerlink" title="OpenHab Serial Device"></a>OpenHab Serial Device</h1><p>如果从数据流的角度去看，OH的串口设备时一种梳状结构：<br>    <div style="width:100%;margin:auto"><img src="/2022/04/15/openhab-serial/0.png" class="" title="OH-Seiral-Structure"></div><br>通过这种树状的级联配置，通过每一级的正则表达式筛选出想要的数据，最终完成同一个串口，分发不同的数据到不同的终端节点上。</p>
<h1 id="配置Serial-Device"><a href="#配置Serial-Device" class="headerlink" title="配置Serial Device"></a>配置Serial Device</h1><ul>
<li><p>在OH中最先需要定义的就是Serial Bridge, 这个节点负责与物理上的串口进行通信，其配置：</p>
  <div style="width:100%;margin:auto"><img src="/2022/04/15/openhab-serial/1.png" class="" title="Serial Bridge"></div>
</li>
<li><p>创建最终的Item<br>  比如温度计，湿度计，开关等</p>
  <div style="width:100%;margin:auto"><img src="/2022/04/15/openhab-serial/2.png" class=""></div>
  
<p>  配置Item, 主要是配置名称和类型，其他内容则不是那么重要</p>
  <div style="width:100%;margin:auto"><img src="/2022/04/15/openhab-serial/3.png" class=""></div>
</li>
<li><p>在Things中创建Serial Device</p>
  <div style="width:100%;margin:auto"><img src="/2022/04/15/openhab-serial/4.png" class=""></div>
  
<p>  修改配置，其中要把Bridge选择为刚创建的Serial Bridge，以便能从串口收发数据，Patern Match则根据需要修改，全匹配为.*</p>
  <div style="width:100%;margin:auto"><img src="/2022/04/15/openhab-serial/5.png" class=""></div>
</li>
<li><p>在创建的Serial Device下面创建Channel<br>  创建Change时必须配置唯一的名称，在”State Transformation”中通过正则表达式过滤出目标数据， “Number Format”中格式化过滤后的数据：</p>
  <div style="width:100%;margin:auto"><img src="/2022/04/15/openhab-serial/6.png" class=""></div>

<p>  完成后通过”Add Link to Item..”从而链接到刚才创建的Item中，从而完成整条线路的配置</p>
  <div style="width:100%;margin:auto"><img src="/2022/04/15/openhab-serial/7.png" class=""></div>
</li>
<li><p>链接Channel与Item<br>  选择”Use an existing Item”，在Item to Link中选择目标</p>
  <div style="width:100%;margin:auto"><img src="/2022/04/15/openhab-serial/9.png" class=""></div>
  <div style="width:100%;margin:auto"><img src="/2022/04/15/openhab-serial/10.png" class=""></div>
  这个REGEX可以完成进一步的数据筛选，默认就是(.*),如果时需要Item获得小数点数据，比如温度这样的，可以使用 (\d*.\d*)
</li>
<li><p>特殊情况，比如开关作为串口输出设备，又是需要输出的内容带换行，但是界面提供的”On Value”和“Off Value”中都不能添加换行符，这种情况就需要在配置完成后，点击保存，然后切换到”Code”页面，在代码中中直接添加\n：</p>
  <div style="width:100%;margin:auto"><img src="/2022/04/15/openhab-serial/8.png" class=""></div>
</li>
<li><p>添加到主界面<br>  在Page栏里面，可以修改页面布局，添加对应的Item到对应的位置，并修改图标等显示相关内容：</p>
  <div style="width:100%;margin:auto"><img src="/2022/04/15/openhab-serial/11.png" class=""></div>
  <div style="width:100%;margin:auto"><img src="/2022/04/15/openhab-serial/12.png" class=""></div></li>
</ul>
]]></content>
      <categories>
        <category>DIY</category>
      </categories>
      <tags>
        <tag>PetProjects</tag>
        <tag>ProjectReverie</tag>
        <tag>SmartHome</tag>
        <tag>OpenHab</tag>
        <tag>Raspberry Pi</tag>
      </tags>
  </entry>
  <entry>
    <title>MSP430 BSL DEBUG</title>
    <url>/2022/09/12/MSP430-BSL-DEBUG/</url>
    <content><![CDATA[<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>中秋节在家，想起来MSP430系列的芯片ISP模式还没有使用过，好奇其工具链的配套的完善程度和具体的使用流程，就打算用手上的MSP430F2272来尝试一下。<br>理想中，使用ISP的好处：</p>
<ol>
<li>一个完整的产品不应该以JTAG为下载方式，就连自己的Pet Projects做完了以后，如果有设计或者使用外壳的情况，用JTAG下载也是极为不方便的，需要拆解外壳连接调试器。 </li>
<li>MSP430F2272的JTAG与ARM Cortex-M家族的SWD不同，需要至少8个PIN：<blockquote>
<p>   Vref, GND, TEST, NRST, TCK, TMS, TDI, TDO<br> 如果采用标准的2.54mm座子则非常占用电路板体积</p>
</blockquote>
</li>
</ol>
<p>常见的SoC厂商，都会在SoC的ROM（第一级引导程序）中加入ISP模式，可以通过一些简单接口就能完成固件的烧写，比如我们最近设计的芯片的ROM中就是以I2C为接口提供ISP的。所以MSP430也一定会有类似的功能。</p>
<span id="more"></span>

<h1 id="BSL"><a href="#BSL" class="headerlink" title="BSL"></a>BSL</h1><p>简单的搜索后得知，TI的给自己的MSP430起了一个不太一样的名字：BSL，二者都是一个意思，名字不同而已。<br>查找F2272 UG得到了一个用户指引教程<a href="https://www.ti.com/lit/ug/slau319ae/slau319ae.pdf?ts=1662983245041">SLAU319</a> 查表就知道F2272支持UART下载。<br>    <div style="width:80%;margin:auto"><img src="/2022/09/12/MSP430-BSL-DEBUG/0.JPG" class=""></div></p>
<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><p>经过调查，BSL的工具大概有几个：</p>
<ol>
<li>MSP-FET，非常早期的GUI工具</li>
<li>MSP-FLASHER， 命令行模式的工具</li>
<li>MSP-GANG， 应该时面向批量编程的</li>
<li>UniFlash， 应该时TI想要打造的通用Flash下载程序</li>
</ol>
<p>本来打算就用UniFlash就足够了，支持F2272， 支持第三方串口模块，但是没想到后面遇到了几个坑，最后把上面几个工具都下载并尝试了一番..但是最后还是用UniFlash成功了。</p>
<p>吐槽一下其他几个工具：<br>MSP-FLASHER, 命令行中允许执行 -i TIUSB | COMn | .., 连接上串口后执行 -i COM2后程序还是会自动尝试寻找USBFET, 没有不行..</p>
<p>MSP-GANG，打开了以后使用串口模式，永远只和COM1通信，COM2被你吃了么..</p>
<h1 id="UniFlash"><a href="#UniFlash" class="headerlink" title="UniFlash"></a>UniFlash</h1><p>打开UniFlash界面后，发现了两个问题：</p>
<ol>
<li>烧写的文件用的时.txt或者.hex, CCS默认的格式时ELF(.out)</li>
<li>ISP模式并不是只用UART就可以了，需要串口模块DTR和RTS： <div style="width:100%;margin:auto"><img src="/2022/09/12/MSP430-BSL-DEBUG/1.JPG" class=""></div>
 也就是DTR<--->NRST,  RTS<--->TEST</li>
</ol>
<p>第二个问题好办，把串口模块的DTR和RTS接出来就好，CP2102芯片是支持UART硬件流控的，第一问题，应该会有两种解决方案：用某种工具转换（TI或者第三方的）， 或者在工程中可能提供了编译链接后可以选择类似GNU下objcopy这样的功能，打开CCS寻找，还真有：<br>    <div style="width:100%;margin:auto"><img src="/2022/09/12/MSP430-BSL-DEBUG/2.JPG" class=""></div><br>    <div style="width:100%;margin:auto"><img src="/2022/09/12/MSP430-BSL-DEBUG/3.JPG" class=""></div><br>在output format中还有很多种格式选择，UniFlash也没有具体提到需要哪种具体格式的，因为没有什么时间慢慢看文档研究了，凭感觉试了两种，最后发现TI-TXT格式可行（TI全家桶么）<br>    <div style="width:100%;margin:auto"><img src="/2022/09/12/MSP430-BSL-DEBUG/4.JPG" class=""></div></p>
<p>生成好.txt后UniFlash中配置串口和波特率，点击“Load Image”提示失败，内容大概是目标设备无响应，检查了连线，按照提示反复掉电上电都没有作用。最后还是花了点时间最后弄明白了，MSP430F2272中BSL用的串口，和片内外设中提供的UART，并不一样！<br>    F2272中用的是P1.1和P2.2<br>    <div style="width:100%;margin:auto"><img src="/2022/09/12/MSP430-BSL-DEBUG/5.JPG" class=""></div><br>    而P1.1和P2.2的具体功能是<br>    <div style="width:100%;margin:auto"><img src="/2022/09/12/MSP430-BSL-DEBUG/6.JPG" class=""></div><br>    <div style="width:100%;margin:auto"><img src="/2022/09/12/MSP430-BSL-DEBUG/7.JPG" class=""></div></p>
<p>飞线后，仍然提示失败，但是错误内容不一样了，日志内容也明显是有通信和握手了，说明软件和芯片已经能正常通信了。最后重新掉电上电后再次尝试，提示成功！<br>    <div style="width:100%;margin:auto"><img src="/2022/09/12/MSP430-BSL-DEBUG/8.JPG" class=""></div></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>总体来说，TI BSL相比于JTAG，在节约PIN脚上优势并不显著，仍然需要：GND，NRST，TEST，BSL-Tx, BSL-Rx五个，比前面提到的JTAG少了三个引脚，而且整体易用度上也比不上STM32的ISP和PiPico的DFU，不过依然可以搭载一个外部的USB-UART桥来完成相对完整的ISP功能，避免了在作品完成后每次需要更新固件都需要拆外壳，拆设备的尴尬。</p>
]]></content>
      <categories>
        <category>Debug</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>超低功耗设计经验总结</title>
    <url>/2022/09/21/ultra-low-power-design/</url>
    <content><![CDATA[<p>从大学开始就断断续续的摸索超低功耗系统的设计，过程中也遇到了很多坑，通过前几次的迭代积累的经验，外加这段时间正好闲下来，完成了一个比较满意的超低功耗传感采集节点的设计，待机电流0.1uA, 工作时包括射频系统在内最大峰值电流30mA，理论上不考虑电池的自放电下，单节CR2032电池可以让设备工作数年. 总结一下经验以便后面的设计能吸取前面的教训，少走弯路。<br>几次迭代的产物：<br>    <div style="width:70%;margin:auto"><img src="/2022/09/21/ultra-low-power-design/1.JPG" class=""></div></p>
<span id="more"></span>
<h1 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h1><p>原始的目标就是设计一个小型的无线传感网络：</p>
<ul>
<li>网络节点采用电池供电</li>
<li>电池续航寿命需要在至少要在1年以上</li>
<li>电池可更换</li>
<li>体积尽可能小</li>
<li>无线收发器需要一定的穿透能力，需要穿透数层钢筋混凝土</li>
<li>节点设备每天触发次数约5-20次</li>
<li>网络要求：<ul>
<li>网络传输加密</li>
<li>可配置中继节点</li>
<li>支持丢包重传</li>
<li>能够识别重放攻击</li>
</ul>
</li>
</ul>
<h1 id="过往的尝试"><a href="#过往的尝试" class="headerlink" title="过往的尝试"></a>过往的尝试</h1><h4 id="第一版"><a href="#第一版" class="headerlink" title="第一版"></a>第一版</h4><p>第一次设计是在大学的时候，作为一个探索小项目，在没有充分的考虑需求和实际设计指标的情况下盲目动手，结果可以说是完全失败的。这个设计采用了单节AA电池供电，一个DCDC-boost芯片负责升压供MCU、RF子系统和传感器共同使用。</p>
<ul>
<li>没有电源分离，单独的使能引脚无法有效切断RF子系统和传感单元的静态电流。</li>
<li>升压电路芯片选型有问题，即便在提前根据手册的最大负荷预留了两倍的载荷，瞬态响应太差以至于在RF部分突然工作时电压瞬间大幅度下降从而影响稳定性，增加大的旁路电容改善有限。</li>
<li>升压芯片本身静态电流就过大，最终导致系统休眠功耗过高</li>
<li>缺少足够的调试接口和逻辑分析仪触点</li>
</ul>
<h4 id="第二版"><a href="#第二版" class="headerlink" title="第二版"></a>第二版</h4><p>尝试用自己设计RF电路来替代模块，并莫名其妙的选择了白色PCB，更改电池为单节CR2032电池，更换主控制器为MSP430F2272, 射频电路采用陶瓷天线替换原来的弹簧天线</p>
<ul>
<li>白色PCB非常难以调试，覆铜和线路之间非常的不明显，难以定位</li>
<li>陶瓷天线衰减太大，无法满足穿透能力的需求</li>
<li>巴伦部分的分立元件质量把控不严（网购三无产品），射频的效果大幅度打折，甚至连26MHz晶振都发错了，将25MHz芯片标注为26MHz发货</li>
<li>加了一个MOS管来切断RF部分电源，但这个电路设计是有问题的，本身漏电流就不算太小</li>
</ul>
<h4 id="第三版"><a href="#第三版" class="headerlink" title="第三版"></a>第三版</h4><p>尝试使用第三方模块，但是这个模块要求3.3V以上供电，为了提高续航采用了两个CR2032串联的方式供电，增加更多的MOS管来完成电源管理和电平转换</p>
<ul>
<li>大开脑洞的供电方式，为了避开升压、降压导致的损耗和静态电流，使用两个电池串联，MCU用下半个电池（2-3V）供电，而射频模块用两个电池（4-6V)供电，这种不平衡的供电方式会导致靠近地端的电池会更快的耗尽</li>
<li>第三方的模块在其上层封装自己的协议更加的复杂</li>
<li>第三方的模块的功耗更高，因为它并不单独的是一个RF收发器，同时增加了一个效率不高的LDO和功耗不小的MCU</li>
</ul>
<h4 id="第四版"><a href="#第四版" class="headerlink" title="第四版"></a>第四版</h4><p>更换了另一种模块只是单纯的继承了RF收发器和巴伦（先绕靠射频的调试），这样更宽的工作电压，不需要两个电池串联来提供更高电压，改成并联来提高总电池容量，这个版本也是雏形都具备了。另外装备了一个与第一版不同的DCDC升压模块给其他传感器供电，型号TPS61021A， 在EN关断时静态电流大概0.4uA，这部分仍然可以继续优化。</p>
<ul>
<li>这个版本对于功耗的管理已经出局雏形，主要的精力用来设计和验证网络协议，并在压力与干扰环境中验证可靠性</li>
</ul>
<h3 id="第五版"><a href="#第五版" class="headerlink" title="第五版"></a>第五版</h3><p>有了前面的经验，这次设计做了进一步的修改：</p>
<ul>
<li>电路上尝试取消RF模块而直接使用RF收发器芯片，并通过MOS可以直接切断其电源</li>
<li>在关键子系统的供电接口处串接0欧姆电阻，以用来进一步分析各种工作模式下，每个子系统的功耗情况</li>
<li>采用的芯片都考察了供电范围，使供电范围可以允许但纽扣电池（CR2032）供电而不再采用外部LDO或者DCDC，以提高效率和减少静态损耗</li>
</ul>
<hr>
<h1 id="经验总结"><a href="#经验总结" class="headerlink" title="经验总结"></a>经验总结</h1><h2 id="宏观"><a href="#宏观" class="headerlink" title="宏观"></a>宏观</h2><p>在开始设计之初，应该花更多的时间思考：核心目标是什么？次要目标是什么？如何拆分这些目标并如何设计各个系统？可能会遇到何种困难并大致如何解决？<br>工程是一种权衡和取舍的过程，需要工程师在设计的时候考虑清楚各个方案的优缺点，包括但不限于各个方案的效果，系统复杂度，部署时间（是否具备一些技术储备以提高部署时间），可维护性和成本。</p>
<p>整体上，并不要太过于贪图一次成功或者一次就能实现所有功能，在电路、系统的复杂度，功耗，体积上同时追求最优。可以适当的放宽第一版的一些指标，比如牺牲体积，增加更多的调试接口和备用方案。</p>
<h2 id="微观"><a href="#微观" class="headerlink" title="微观"></a>微观</h2><h4 id="I-认真考虑核心需求，并围绕核心需求严谨的展开设计"><a href="#I-认真考虑核心需求，并围绕核心需求严谨的展开设计" class="headerlink" title="I. 认真考虑核心需求，并围绕核心需求严谨的展开设计"></a>I. 认真考虑核心需求，并围绕核心需求严谨的展开设计</h4><p>比如低功耗传感设备，那么低功耗必然为核心需求，这就需要综合的考察到底多低才能满足需要，是一节AA电池还是一节纽扣电池？更换一次电池或者充电一次到底需要工作多久？休眠与工作的时间比例以及二者功耗的差异。</p>
<h4 id="II-开始具体的设计前，关键的电路要进行仿真，确保漏电流，负载电流和环路响应在内的各种指标达到需求，并留有足够的冗余"><a href="#II-开始具体的设计前，关键的电路要进行仿真，确保漏电流，负载电流和环路响应在内的各种指标达到需求，并留有足够的冗余" class="headerlink" title="II. 开始具体的设计前，关键的电路要进行仿真，确保漏电流，负载电流和环路响应在内的各种指标达到需求，并留有足够的冗余"></a>II. 开始具体的设计前，关键的电路要进行仿真，确保漏电流，负载电流和环路响应在内的各种指标达到需求，并留有足够的冗余</h4><p>在设计电路前能充分的了解电路的特点和对应元件参数的调节会为后期实际硬件的调试避免走很多弯路，节约大量时间。</p>
<h4 id="III-不同的功能单元具有单独的电源域，独立控制"><a href="#III-不同的功能单元具有单独的电源域，独立控制" class="headerlink" title="III. 不同的功能单元具有单独的电源域，独立控制"></a>III. 不同的功能单元具有单独的电源域，独立控制</h4><p>一个系统中，从低功耗唤醒中并不是所有的的单元同时开始工作，比如采集数据-整理分析数据-传输数据这种模型，不同阶段可以使能不同的单元，从而降低工作时间的峰值功耗。</p>
<h4 id="IV-不要盲目相信芯片、模块的使能引脚"><a href="#IV-不要盲目相信芯片、模块的使能引脚" class="headerlink" title="IV. 不要盲目相信芯片、模块的使能引脚"></a>IV. 不要盲目相信芯片、模块的使能引脚</h4><p>很多芯片、模块提供了使能引脚，前面提到的单独控制时，使能引脚，设置包括复位在内，并不能等同于电源控制，使能或者复位仅仅是让门电路停止翻转，而并不是关断电源或者设定到一个适合的状态从而满足最低功耗的需求。比如我们最近设计的芯片，如果是拉低复位，SoC的电流反比最低功耗睡眠的情况下大很多。这种情况下，独立的外部电源控制电路是必要的。</p>
<h4 id="V-电阻-电阻-电阻"><a href="#V-电阻-电阻-电阻" class="headerlink" title="V. 电阻-电阻-电阻"></a>V. 电阻-电阻-电阻</h4><p>很多平常用的电路中，电阻的大小需要进行调整，比如10K上拉，如果是3.3V供电，电路导通的时候流过电阻的电流大约就是0.33mA。适当增大电阻可以减小这部分消耗的电流，但是电阻越大，对于模拟电路而言热噪声越显著，而数字电路则需要考虑更好的电磁兼容设计，微弱的感应电流就有可能导致系统的误动作。</p>
<h4 id="VI-除了必要的硬件调试接口，关键的分路应该还预留有电流测试的接口"><a href="#VI-除了必要的硬件调试接口，关键的分路应该还预留有电流测试的接口" class="headerlink" title="VI. 除了必要的硬件调试接口，关键的分路应该还预留有电流测试的接口"></a>VI. 除了必要的硬件调试接口，关键的分路应该还预留有电流测试的接口</h4><p>总电源处的电流测试点可以让测试者了解系统的整体功耗，但是一旦在开发过程中开始尝试优化系统功耗，能够快速了解每个子单元的功耗会对调试提供更好的指向性，节约许多调试时间。</p>
<h4 id="VII-了解分立元件"><a href="#VII-了解分立元件" class="headerlink" title="VII. 了解分立元件"></a>VII. 了解分立元件</h4><p>在追求极端的低功耗时，充分的了解每一个元件是大有益处的，借助可靠的元件供应商，使用具有具体规格的元件, 避免采购三无元件</p>
<p>另外一点，小批量时，用在同一处的元件尽量采用相同的供应商的元件。例如某特定的一个模拟电路中相同型号分离元件，比如同一型号的MOSFET可能有多个厂商提供，而不同的厂商生产的此型号MOSFET在某些极限指标并不相同。</p>
<h4 id="VIII-深入了解微控制器的低功耗模型"><a href="#VIII-深入了解微控制器的低功耗模型" class="headerlink" title="VIII. 深入了解微控制器的低功耗模型"></a>VIII. 深入了解微控制器的低功耗模型</h4><p>不同的微控制器具有不同的低功耗模型，有的SoC具备多个片内电源域，有的SoC并不是全内存保留（Memory Retention), 唤醒方式，唤醒时间皆不相同，需要根据具体情况和具体需求设计。<br>最近调试的低功耗芯片就是TI的MSP430F系列的微控制器， 这个MCU提供了多种低功耗模式的选择<br>手册提供的数据：<br>    <div style="width:100%;margin:auto"><img src="/2022/09/21/ultra-low-power-design/2.JPG" class=""></div><br>实际测试LPM3 （VLO-&gt;ACLK):<br>    <div style="width:30%;margin:auto"><img src="/2022/09/21/ultra-low-power-design/3.JPG" class=""></div><br>实际测试LPM4：<br>    <div style="width:30%;margin:auto"><img src="/2022/09/21/ultra-low-power-design/4.JPG" class=""></div><br>在MSP430中，LPM3和LPM4的使用范围又是有区别的，虽然LPM3、LPM4所有的寄存器和内存都是保留模式，但是LPM4会切断所有的时钟，只有外部中断能唤醒系统。LPM3会保留ACLK， ACLK可以来自外部低速时钟，也可以来自与内部的VLO，VLO的频率范围是4KHz-20KHz, 典型值是12KHz, 也就意味着LPM3下，MSP430可以通过内部timer自我唤醒。</p>
<h4 id="IX-IO"><a href="#IX-IO" class="headerlink" title="IX. IO"></a>IX. IO</h4><p>正确的配置芯片的工作模式和GPIO，在超低功耗的情况下，IO的正确配置是至关重要的，工作模式下，整体功耗50mA，IO额外消耗的10uA是微不足道的，但是低功耗下，整个系统的功耗&lt;&#x3D;1uA时，IO导致的额外的10uA则是非常可观的了。而IO的配置并不是简单的把所有的IO配置为输入、输入就可以了，需要根据具体电路调整，有些需要配置为输入，有些需要配置为输出低，而个别IO，需要在低功耗状态下配置为某个状态而避免漏电流、灌电流，但唤醒后则需要切换到另外的状态</p>
<h4 id="X-慎重使用不熟悉的第三方模块"><a href="#X-慎重使用不熟悉的第三方模块" class="headerlink" title="X. 慎重使用不熟悉的第三方模块"></a>X. 慎重使用不熟悉的第三方模块</h4><p>有时候采用第三方模块会大大简化系统和软件的设计，低功耗系统如何去集成第三方模块是需要综合考虑的，可能会简化设计，也可能会带来限制应用、工作范围。比如有些模块的工作范围是2.8V-5.5V，如果配合一节AA电池或者1节CR2032电池，那么这样的模块的使用是需要额外的升压电路的。典型的CR2032电池的放电曲线， 电池放电在2.8V以后仍然可以持续放电<br>    <div style="width:70%;margin:auto"><img src="/2022/09/21/ultra-low-power-design/5.JPG" class=""></div><br>而额外的升压电路则意味着功耗的增加和电路面积的增加</p>
<h4 id="XI-奥卡姆剃刀-简单才是硬道理"><a href="#XI-奥卡姆剃刀-简单才是硬道理" class="headerlink" title="XI. 奥卡姆剃刀 - 简单才是硬道理"></a>XI. 奥卡姆剃刀 - 简单才是硬道理</h4><p>简单来说 - 一上来不要整那么复杂，优先实现最核心的功能并保持系统的低功耗状态，并在不断增加功能-升级优化驱动的时候关注低功耗的变化，避免在某些情况下，修改了外设而这个外设会在低功耗的情况下带来意想不到的变化。</p>
<h4 id="XII-优先设计软件模型，并在可能的开发环境下验证软件"><a href="#XII-优先设计软件模型，并在可能的开发环境下验证软件" class="headerlink" title="XII. 优先设计软件模型，并在可能的开发环境下验证软件"></a>XII. 优先设计软件模型，并在可能的开发环境下验证软件</h4><p>在不能充分了解软件-硬件系统的情况下，很多时候会出现硬件设计完了，软件的很多地方无法适配需要更改硬件或者更改软件原有架构。一个简单的例子时，一些I2C从设备是支持clock stretching的，而如果I2C主设备不支持，这样则无法有效使用SoC的硬件I2C，此时如果软件更换采用GPIO bit-banging, 则需要考虑是否屏蔽中断，包括优先级更高的中断从而保证时许，这会带来整体软件设计的新的挑战，而在设计的早期能认识到诸如此类的问题，对于系统的整体规划和设计是大有帮助的。</p>
<h4 id="XIII-追求某些极致的参数时，分两步设计可能可能会更节约时间"><a href="#XIII-追求某些极致的参数时，分两步设计可能可能会更节约时间" class="headerlink" title="XIII. 追求某些极致的参数时，分两步设计可能可能会更节约时间"></a>XIII. 追求某些极致的参数时，分两步设计可能可能会更节约时间</h4><p>在复杂的设计中出现意料之外的事情可以说是很难避免的，而第一版设计可以放宽某些特性，比如电路板的面积，增加更多的硬件-软件调试接口的测试点，第一个版本更加关注功能的实现，当一些就绪后，随后可以进行第二个版本减小面积，降低成本。这样即便第二部出现新的问题，也能通过和第一个版本比较从而更快的定位到问题所在</p>
<h4 id="XIV-考虑好高低功耗状态的切换"><a href="#XIV-考虑好高低功耗状态的切换" class="headerlink" title="XIV. 考虑好高低功耗状态的切换"></a>XIV. 考虑好高低功耗状态的切换</h4><p>既然是低功耗系统，那么必然会有频繁的高低功耗状态切换，切换中，那些子系统，那些片内外设是需要保留，而另外一部分需要唤醒后恢复，切换过程中寄存器的配置，IO的配置以及软件结构体的维护都是需要考虑的。比如某些情况下，低功耗唤醒后需要进行部分初始化，这些初始化需要避开POR后初始化过的一些软件结构体和指针，在了解这些后，在最初设计驱动初始化API时就可以统一考虑。</p>
]]></content>
      <categories>
        <category>DIY</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>PetProjects</tag>
      </tags>
  </entry>
  <entry>
    <title>Raspberry Pi Pico不使用按键进入下载模式(MSD)</title>
    <url>/2023/03/07/pipico-download-mode/</url>
    <content><![CDATA[<p>最近发现了一个小的Pi Pico使用技巧。 Pi Pico除了使用SWD下载和调试以外，还可以通过按下BOOTSEL后上插上USB来进入下载模式，此时系统中将会枚举出一个大容量存储设备，将编译好的UF2文件拖入就可以下载了。</p>
<p>这样的下载模式非常的简单，但是在真实应用中有个麻烦：如果一旦电路板装入设备中，装上外壳之后再进行固件更新就相对恼火了，无论时SWD接口或者时BOOTSEL按键，都不大可能会再外壳上预留出来。</p>
<p>Pi Pico官方给了一种Picotool可以使用-f参数通过USB强制Pi Pico进入下载模式并更新固件。除了这种方法外，还有一种办法可以快速的，不通过BOOTSEL按键使Pi Pico进入下载模式。</p>
<span id="more"></span>

<p>首先需要将USB配置为stdio设备，也就是再电脑上枚举为CDC设备，在CMakeLists.txt中添加：</p>
<blockquote>
<p>pico_enable_stdio_usb(project_name 1)</p>
</blockquote>
<p>在C语言环境中执行：</p>
<blockquote>
<p>#include “pico&#x2F;stdlib.h”<br>#include “stdio.h”<br>stdio_init_all();</p>
</blockquote>
<p>在电脑上用串口助手（比如TeraTerm)打开这个枚举好的CDC设备，修改波特率为1200后Pi Pico就会自动断开，然后重新枚举为新的MSD，可以拖入UF2完成固件更新。</p>
]]></content>
      <categories>
        <category>PiPico</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>PetProjects</tag>
        <tag>PiPico</tag>
        <tag>Jlink</tag>
        <tag>SWD</tag>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>Hack一个小冰箱</title>
    <url>/2023/03/07/hack-thermobox/</url>
    <content><![CDATA[<p>最近买了一个半导体冷热小冰箱，使用了一阵子后发现了一些问题，最主要的就是温控的不准确。冰箱门板上带有数显数控的功能，但是经过测试发现实际内部的温度和设定的温度差别比较大，误差6-7摄氏度都是常有的。<br>    <div style="width:40%;margin:auto"><img src="/2023/03/07/hack-thermobox/0.jpg" class="" title="origin_curve"></div><br>上面的就是一天的温度曲线，设定的温度为20摄氏度，环境温度白天约15度左右，每天大概7点半左右空调会打开加热，所以才有这样的温度变化趋势，冰箱应该自动识别为制冷模式了，在达到了设定温度后，之后全程为保温模式，温度的波动也全因为外界的温度波动。这样的温控也就勉强能放点冷热饮了，所以决定尝试改造一下，让自己制作的温控替代冰箱原本的温控。</p>
<span id="more"></span>

<h1 id="拆解"><a href="#拆解" class="headerlink" title="拆解"></a>拆解</h1><p>原本的样子，正面是数显数控面板：<br>    <div style="width:55%;margin:auto"><img src="/2023/03/07/hack-thermobox/1.jpg" class="" title="front"></div><br>背面支持220V交流输入或者车载12V直流输入:<br>    <div style="width:55%;margin:auto"><img src="/2023/03/07/hack-thermobox/2.jpg" class="" title="back"></div><br>内部壳体上的螺丝表明半导体制冷片就被固定在后面：<br>    <div style="width:55%;margin:auto"><img src="/2023/03/07/hack-thermobox/3.jpg" class="" title="internal"></div><br>门与箱体之间隐藏的连接线，如果要替代原有的温控，大概率就要搞清楚这几根线的作用：<br>    <div style="width:55%;margin:auto"><img src="/2023/03/07/hack-thermobox/4.jpg" class="" title="wire"></div><br>后盖比较容易拆下，打开后露出了半导体制冷片另外一端的散热片和风扇，以及电源板和控制板：<br>    <div style="width:55%;margin:auto"><img src="/2023/03/07/hack-thermobox/5.jpg" class="" title="ctrl_board1"></div><br>细节：<br>    <div style="width:55%;margin:auto"><img src="/2023/03/07/hack-thermobox/6.jpg" class="" title="detail1"></div><br><em>吐槽一下：电源板上有关EMI的东西全部拿掉了，真是无所不用其极的降低成本啊</em><br><em>再次吐槽：背面的散热器应当要考虑稍微倾斜一下，当冰箱是制热模式时，长时期的制热会让散热片温度很低，鳍片结冰后融化的水无法有效引导走，就可能流入下方风扇的电线的接口处，如果风扇没有做任何防水处理则可能导致短路。不过看前面冰箱的温控模式，大概率它也没打算长时间工作的样子。</em></p>
<p>拆下控制板：<br>    <div style="width:55%;margin:auto"><img src="/2023/03/07/hack-thermobox/7.jpg" class="" title="ctrl_board2"></div></p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>在尝试分析之前，我的猜测是后面的控制器为主控，而前面板的显示和触摸应该是个伺服控制器完成的，把控制信息传给主控，而主控则把温度信息传给伺服控制器用于显示：<br>    <div style="width:100%;margin:auto"><img src="/2023/03/07/hack-thermobox/theory.jpg" class=""></div><br>我需要做的大概就是找一个以前的某个单片机的板子替换这个主控，破解伺服控制器通信的编码，然后通过传感器读取冰箱内温度，再根据设定温度来控制半导体制冷片具体是加热或者制冷的动作。</p>
<p>控制板背面，通过万用表测试后知道了和前面板连接线的大概定义，分别为5V，GND，热敏电阻和一个控制信号：<br>    <div style="width:55%;margin:auto"><img src="/2023/03/07/hack-thermobox/8.jpg" class="" title="ctrl_board_back"></div><br>既然知道了背面的控制器和前面屏幕与按钮是通过一个控制信号来通信的，挂上示波器看波形：<br>    <div style="width:55%;margin:auto"><img src="/2023/03/07/hack-thermobox/9.jpg" class="" title="hook"></div><br>波形：<br>    <div style="width:55%;margin:auto"><img src="/2023/03/07/hack-thermobox/10.jpg" class="" title="wave"></div></p>
<p>这个波形大概率应该是一个串口，那么就是单向的通信，而且通过单独断开这个信号线，发现这个信号是从屏幕面板送到后面的控制器的，接上逻辑分析仪分析信号确定为串口，波特率是9600。这个信号接上一个串口模块，在电脑上读取到信息：<br>    <div style="width:55%;margin:auto"><img src="/2023/03/07/hack-thermobox/12.jpg" class=""></div><br>    <div style="width:55%;margin:auto"><img src="/2023/03/07/hack-thermobox/13.jpg" class=""></div><br>发现传输的内容非常简单，调节面板上的温度，控制内容并不变化，也就意味着这个传输的是一个并不包含任何温度的控制信息，尝试让冰箱进入制冷、制热、关机等模式，发现了控制命令只有5种，每个包总长4字节，其基本结构为：</p>
<blockquote>
<p>[包头] [控制字1] [控制字2] [包尾]</p>
</blockquote>
<p>包头为固定的0xe7, 包尾为固定的0x7e, 而两个控制字：</p>
<figure class="highlight plaintext"><figcaption><span>控制命令</span></figcaption><table><tr><td class="code"><pre><span class="line">关机      0x00, 0xff</span><br><span class="line">制冷准备   0x03, 0xfc</span><br><span class="line">制冷      0x04, 0xfb</span><br><span class="line">制热准备   0x01, 0xfe</span><br><span class="line">制热      0x02, 0xfd</span><br></pre></td></tr></table></figure>

<p>整理一下不难发现，控制字2就是控制字1的反码，那么其实就是对应着关机(0x00)，制热主备(0x01)，制热(0x02)，制冷准备(0x03)，制冷(0x04)。<strong>然后断开这个控制信号，用串口模块发送一个5V TTL电平的命令，模仿这些命令让控制器产生相应的动作，确定了对于命令内容猜想的正确。</strong></p>
<p>这就意味着前面猜测的系统结构是不对的，后面的控制器并不是主控制器，前面的屏幕和触摸按键的控制器才是，暂且称之为前控制器，前控制器获取用户输入的设定温度，同时获取了NTC的信号，知道当前冰箱内温度，那么它是单向的向后控制器发五种命令：关机、制冷准备、制冷、制热准备、制热。如果冰箱内温度达到设定的温度，那么它就发送停止加热&#x2F;制冷的命令，简单来说就是开关的控制方式。</p>
<p>再来拆看前控制器看看，在密封条的背面找到了螺丝：<br>    <div style="width:55%;margin:auto"><img src="/2023/03/07/hack-thermobox/15.jpg" class=""></div><br>拆下前面板：<br>    <div style="width:55%;margin:auto"><img src="/2023/03/07/hack-thermobox/16.jpg" class=""></div><br>前控制器背面，用的是一个BYD的单片机：<br>    <div style="width:55%;margin:auto"><img src="/2023/03/07/hack-thermobox/17.jpg" class=""></div></p>
<p>看来需要替换的是前控制器而不是后控制器，这就比较麻烦了，意味着如果这么做，除了需要读取温度，编解码通信和控制半导体制冷片外，还需要增加触摸按键，触摸按键一般是电容检测的模式，比普通的GPIO要麻烦一些，还需要接管数码管来显示温度，最麻烦的是，数码管，LED灯和按键都是有位置的要求，大概率无法使用以前做好的PCB去快速的替换，需要针对这些设备和物理位置重新设计一个PCB，这样太浪费时间了。</p>
<h1 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h1><p>通过前面的分析有两个可行的方案可以选择</p>
<h2 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h2><p>完整的替换前控制器，做一个PCB板，具有和前控制器一样的数码管，LED，触摸按键的布局。<br>优点：</p>
<ul>
<li>人机交互可以保证一模一样，使用者不可察觉</li>
</ul>
<p>缺点：</p>
<ul>
<li>无法利用已有的PCB来完成这一目标</li>
<li>重新设计一个对应功能、尺寸、布局的PCB会浪费更多的时间，不会是一个两三天可以完成的工作</li>
</ul>
<h2 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h2><p>断开前后控制器的控制信号，新加入一个”中间人“控制器，用来读取当前冰箱内温度和发送对应的控制信号<br>优点：</p>
<ul>
<li>可以利用现成的PCB稍作修改就能使用</li>
</ul>
<p>缺点：</p>
<ul>
<li>无法获取用户的温度设定，前控制器并不将这些信息发送出来，只是发送五种动作指令</li>
<li>由于采用另外的数字温度传感器替代并不精确的热敏电阻（不准确可能和校准与安装位置有关），而两个型号不同、位置也不相同的传感器，则会导致真实的温度（控制温度）和面板上显示的温度并不一致</li>
<li>无法再使用前面板的人机交互</li>
</ul>
<p>最后还是采用方案二，不希望花太多的时间和精力，同时关于人机交互的缺失，可以通过加入无线网络来弥补，利用云端远程的设置温度，并实时监视和记录冰箱内温度。</p>
<p>最终采用的方案如下：<br>    <div style="width:100%;margin:auto"><img src="/2023/03/07/hack-thermobox/design.jpg" class=""></div></p>
<p>考虑和设计如下：</p>
<ol>
<li>“中间人”控制器选用去年制做的Pi Pico的板子，稍微改造一下外接一个数字温湿度计SHT20，一个数字温度计DS18B20</li>
<li>这个控制器上有AMS1117用来降压，理论上可以直接12V，但是：<ul>
<li>AMS1117理论上的最大输入电压是15V，12V已经接近理论极限</li>
<li>冰箱自带的电源板更像是追求极致成本的产物，其12V输出未必可靠</li>
<li>已有的AMS1117货源不可靠，其真实输入耐压和热阻不详</li>
<li>所以综合考虑这个“中间人”控制器和显示控制电路共享5V</li>
</ul>
</li>
<li>共享的5V来自于一个贴片的7805，其输入电压为12V，那么考虑7805过热的风险，经过测量原有显示触摸电路电流大概在15-20mA左右, “中间人”控制器估计电流在50mA左右，那么整体7805的电流大概在80mA以下，根据热阻的计算7805应该能够承受</li>
<li>采用SHT20为主温度传感器，可以同时采集湿度，实时监测小冰箱内的湿度情况</li>
<li>另外一个DS18B20为环境温度传感器，通过网上搜集的资料了解到，反复的冷热交换会对半导体制冷片的寿命带来较为显著的影响，所以为了尽量避免冷热模式切换，同时节约能源，采用一个额外的传感器监控外部环境温度，这样半导体制冷片只用工作在单模式，环境温度低于目标温度则制热，到达设定温度后保温模式下靠自然散热，当温度再次降到足够低时只用继续制热即可，制冷模式的原理亦然</li>
<li>在原有后主控上控制散热片风扇边额外增加一个12V风扇的接口，这个风扇将会在冰箱（应该更名为温箱了）内部，对着冷热温度最集中的区域（两个半导体制冷片中间）的地方进行散热，让热量更快更均匀的扩散</li>
<li>无线收发模块用来实时传输当前状态，和接收目标温度的设定</li>
<li>USB口也外接出来，让USB平时工作在CDC类下，内部实现一个命令行工具，外接一个计算机也可以通过这个命令行来调整各种运行参数，目标温度和监控状态</li>
<li>外接的USB同时也作为固件更新的接口</li>
<li>打开看门狗，防止可能的电源或者EMI导致的故障，保障一定的故障恢复能力</li>
</ol>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><p>改造过的Pi Pico板子：<br>    <div style="width:60%;margin:auto"><img src="/2023/03/07/hack-thermobox/18.jpg" class=""></div><br>稍作修改的原主控：<br>    <div style="width:60%;margin:auto"><img src="/2023/03/07/hack-thermobox/19.jpg" class=""></div><br>系统组装后：<br>    <div style="width:60%;margin:auto"><img src="/2023/03/07/hack-thermobox/20.jpg" class=""></div></p>
<p>在软件的实现过程中，需要注意的是，温度的控制需要使用PID，冰箱，甚至包括半导体制冷片的工作模型，都是一个大迟滞非线性系统，简单的逻辑控制或者经验控制并能有效的控制温度。PID算法本身并不复杂，可以参考Arduino PID library和这篇<a href="http://brettbeauregard.com/blog/2011/04/improving-the-beginners-pid-introduction/">文章</a>，写的很通俗易懂。</p>
<p>PID麻烦的地方在于调参，在不清楚系统模型的基础上，PID参数的差异可能是数量级的差异。所以为了方便调参，在面提到的小命令行中加入了PID调节的相关命令，并将这些参数存储在Pi Pico内部的flash上，可以动态的调节PID的参数从而寻找最佳的参数组合，同时不用担心掉电丢失的问题。</p>
<p>在实物上调节PID参数是费时的工作，为了加快寻找合适的PID参数范围，通过记录前面冰箱内温度的变化，把这些数据当作输入，在Jupyter上设计了一个简单的PID仿真程序，能加快寻找到PID参数的大致范围。</p>
<p>最后将仿真得到的粗略的PID参数设置在冰箱上，得到下面的实际运行的温度变化曲线：<br>    <div style="width:60%;margin:auto"><img src="/2023/03/07/hack-thermobox/21.png" class=""></div><br>以后进一步的优化和调节PID，可以让温度变化更好的震荡在目标温度上下。</p>
<p>项目地址：[TBD]</p>
]]></content>
      <categories>
        <category>DIY</category>
        <category>PiPico</category>
      </categories>
      <tags>
        <tag>嵌入式</tag>
        <tag>PetProjects</tag>
        <tag>ProjectReverie</tag>
        <tag>PiPico</tag>
      </tags>
  </entry>
</search>
